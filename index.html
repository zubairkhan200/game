<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
<title>Car Fire Combat – Responsive (Portrait + Landscape)</title>
<style>
  /* ===== Root, colors, and global sizing ===== */
  :root{
    --neon:#7cf; --accent:#ff7b1f; --hud:#13b87a; --danger:#ff5454; --gold:#ffd86b;
    --glass: rgba(13,17,23,.40); --glass-strong: rgba(13,17,23,.62); --stroke: rgba(255,255,255,.08);
    --outer-glow: 0 12px 50px rgba(0,0,0,.55); --soft-inner: inset 0 1px 0 rgba(255,255,255,.06);
    --card-radius: 14px;
    --bg-start:#900000; --bg-end:#900000;
    /* easy one-knob control for size */
    --fire-size: clamp(84px, 14vh, 132px);     /* was ~48–72px */
    --fire-icon: clamp(26px, 5vh, 34px);       /* bigger emoji/icon */
  }
  html,body{height:100%;margin:0}
  body{
    display:flex;align-items:center;justify-content:center;height:100svh;
    background: radial-gradient(1200px 800px at 50% 20%, var(--bg-start) 0%, var(--bg-end) 60%, #9fc4ff 100%);
    font-family: ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
    color:#0b1a27; overflow:hidden; -webkit-tap-highlight-color: transparent;
    padding: env(safe-area-inset-top,0) env(safe-area-inset-right,0) env(safe-area-inset-bottom,0) env(safe-area-inset-left,0);
    touch-action: none;
  }

  /* Container centers the canvas. No cropping, no overflow. */
  #game-container{
    position:relative; width:100vw; height:100svh; margin:auto;
    display:flex; align-items:center; justify-content:center; overflow:hidden;
  }

  /* Let JS control the canvas size; keep visuals crispy */
  #game-canvas{
    display:block; border-radius:16px;
    box-shadow:0 28px 90px rgba(0,0,0,0.35);
    background:#e9f5ff; /* bright base behind arena */
    image-rendering: optimizeQuality; touch-action: none;
    width: min(100vw, 1280px);
    height: min(100vh, 720px);
    max-width: 100%;
    max-height: 100%;
  }

  .ui-strong{font-weight:900; letter-spacing:.08em; text-transform:uppercase; text-shadow:0 0 10px rgba(124,220,255,.35), 0 0 22px rgba(0,150,255,.18)}
  .ui-outline{-webkit-text-stroke: 1px rgba(0,0,0,.12); text-shadow:0 1px 2px rgba(0,0,0,.2)}
  .glass{ background: linear-gradient(180deg, rgba(255, 255, 255, 0), rgba(255, 255, 255, 0)); border-radius: var(--card-radius); border: 1px solid rgba(0,0,0,.08); box-shadow: var(--soft-inner), var(--outer-glow); position: relative; overflow: hidden; }
  .glass::before{ content:""; position:absolute; inset:-1px; border-radius: inherit; padding:1px;
    background: linear-gradient(135deg, rgba(124,220,255,.55), rgba(255,136,68,.45), rgba(72,255,167,.45));
    -webkit-mask: linear-gradient(#000 0 0) content-box, linear-gradient(#000 0 0);
    -webkit-mask-composite: xor; mask-composite: exclude; pointer-events:none; opacity:.55;
  }

  /* HUD */
  #hud { position: absolute; left: 8px; top: 8px; padding: 4px 6px; min-width: 140px; z-index: 11; font-size: 10px; }
  #hud .row { display: flex; gap: 4px; flex-wrap: wrap; justify-content: center; }
  #hud .stat { font-size: 9px; margin: 1px 0; padding: 2px 4px; border-radius: 6px; background: #bf0000; color: #fff; min-width: 48px; text-align: center; }
  #hud .stat span { font-weight: 700; min-width: 16px; }

  /* Top controls */
  #controls { position: absolute; right: 6px; top: 6px; display: flex; gap: 4px; align-items: center; padding: 4px 6px; z-index: 11; }
  #controls .btn { cursor: pointer; border: none; background: linear-gradient(180deg, #ff6b00, #ff3d00); color: #fff; font-weight: 700; padding: 3px 6px; border-radius: 6px; font-size: 10px; letter-spacing: .04em; text-transform: uppercase; border: 1px solid rgba(0,0,0,.15); box-shadow: inset 0 0 0 1px rgba(255,255,255,.25); transition: transform .06s ease, box-shadow .2s ease; }
  #controls .btn.active { background: linear-gradient(180deg,#1f2937,#0f1724); color: #a7ffb8; box-shadow: 0 0 0 1px rgba(167,255,184,.18) inset; }
  #vol { width: 60px; height: 12px; }

  /* Overlay */
  #overlay{position:absolute;inset:0;display:flex;align-items:center;justify-content:center;background:rgba(255,255,255,0.35);backdrop-filter:blur(6px);text-align:center;z-index:20;color:#0b1a27; perspective: 1000px; }
  #overlay.hidden{display:none}
  #overlay .box{padding:22px 24px; min-width:300px;}
  #overlay h1{margin:0 0 10px;font-size:26px;letter-spacing:.08em}
  #overlay p{margin:6px 0 16px;font-size:13px;opacity:.92}
  #overlay .actions{display:flex;gap:10px;justify-content:center;flex-wrap:wrap}
  #diffRow{display:flex;gap:8px;justify-content:center;margin:12px 0 8px;flex-wrap:wrap}
  .choice{padding:7px 10px;border-radius:10px;background:linear-gradient(208deg, #38bdf8, #ffffff00);cursor:pointer;border:1px solid rgba(0,0,0,0.08); font-weight:900;letter-spacing:.06em;text-transform:uppercase;font-size:12px;color:#0b1a27}
  .choice.active{background:linear-gradient(180deg,#1f2937,#0f1724);color:#a7ffb8;box-shadow:0 0 0 2px rgba(167,255,184,.15) inset}

  /* ===== Mobile Controls (glass buttons) ===== */
  .mc-wrap{ position:absolute; bottom:12px; z-index:12; display:none; flex-direction:column; gap:12px; pointer-events:none; padding-bottom: calc(env(safe-area-inset-bottom,0) + 4px); }
  /* left removed (joystick floats) */
  #mobile-right{ right:12px; align-items:flex-end; }

  #fireBtn { opacity: 0.5; user-select: none; -webkit-user-select: none; -ms-user-select: none; touch-action: manipulation; }
  .mc-btn { pointer-events: auto; width: var(--fire-size); height: var(--fire-size); border-radius: 50%; position: relative; border: 1px solid rgba(0,0,0,.15); touch-action: none; display: grid; place-items: center; font-weight: 900; color: #fff; background: radial-gradient(circle at 30% 30%, #ff6b6b, #c53030); box-shadow: 0 16px 50px rgba(0,0,0,.25), inset 0 0 0 2px rgba(255,255,255,.5); -webkit-backdrop-filter: blur(8px); backdrop-filter: blur(8px); overflow: hidden; -webkit-touch-callout: none; }
  #fireBtn span { position: relative; z-index: 1; font-size: clamp(18px, 4vh, 24px); pointer-events: none; }

  /* Floating Glass Joystick — 50% bigger than fire button */
  #joy { position: absolute; inset: 0; z-index: 13; pointer-events: none; }
  #joy.hidden { display: none; }
  #joyBase { position: absolute; width: clamp(72px, 12vh, 108px); height: clamp(72px, 12vh, 108px); margin-left: calc(-0.5 * clamp(72px, 12vh, 108px)); margin-top:  calc(-0.5 * clamp(72px, 12vh, 108px)); border-radius: 50%; border: 2px solid #93c5fd; background: radial-gradient(60% 60% at 50% 50%, rgba(96,165,250,.35), rgba(59,130,246,.65) 65%, rgba(30,58,138,.6) 66%) padding-box, linear-gradient(180deg, rgba(255,255,255,.9), rgba(230,242,255,.9)) border-box; box-shadow: var(--soft-inner), 0 18px 60px rgba(0,0,0,.25); -webkit-backdrop-filter: blur(10px); backdrop-filter: blur(10px); }
  #joyStick { position: absolute; width: clamp(42px, 8vh, 80px); height: clamp(42px, 8vh, 80px); margin-left: calc(-0.5 * clamp(42px, 8vh, 80px)); margin-top:  calc(-0.5 * clamp(42px, 8vh, 80px)); border-radius: 50%; border: 2px solid #bfdbfe; background: radial-gradient(circle at 40% 40%, #60a5fa, #1d4ed8); box-shadow: inset 0 0 0 2px rgba(255,255,255,.85), 0 12px 40px rgba(0,0,0,.2); -webkit-backdrop-filter: blur(8px); backdrop-filter: blur(8px); }

  /* Show controls on touch in BOTH orientations */
  @media (pointer: coarse) {
    #mobile-right { display: flex; }
  }

  /* Floating text (used in game feedback) */
  .floating-text{position:absolute;pointer-events:none;font-weight:1000;font-size:22px;text-align:center;padding:8px 12px;border-radius:12px;z-index:10;transform:translate(-50%,-50%);white-space:nowrap;animation:floatUp 1100ms ease-out forwards; letter-spacing:.06em;background:linear-gradient(180deg, rgba(255,255,255,.90), rgba(255,255,255,.70));border:1px solid rgba(0,0,0,.12);box-shadow: inset 0 0 0 1px rgba(255,255,255,.7), 0 10px 30px rgba(0,0,0,.12);-webkit-backdrop-filter: blur(4px); backdrop-filter: blur(4px); color:#0b1a27;}
  .floating-text.red{color:#fff !important;background:linear-gradient(180deg, rgba(255,78,78,.92), rgba(240,0,0,.92));border-color: rgba(0,0,0,.1);box-shadow: 0 12px 30px rgba(255,60,60,.25), 0 8px 24px rgba(0,0,0,.2);-webkit-text-stroke: 0 transparent !important;text-shadow: 0 2px 10px rgba(0,0,0,.25);}
  @keyframes floatUp{0%{opacity:1;transform:translate(-50%,-50%) translateY(0) scale(1)}100%{opacity:0;transform:translate(-50%,-200%) translateY(-24px) scale(1.06)}}

  .visually-hidden{ position:absolute !important; width:1px !important; height:1px !important; padding:0 !important; margin:-1px !important; overflow:hidden !important; clip:rect(0,0,0,0) !important; white-space:nowrap !important; border:0 !important; opacity:0.001 !important; pointer-events:none !important; }

  /* ===== 3D Overlay Container ===== */
  .menu3d { --depth: 26px; --rim: rgba(124,220,255,.35); position: relative; padding: 16px 18px; min-width: 260px; border-radius: 16px; background: linear-gradient(180deg, rgba(15,23,42,.92), rgba(15,23,42,.78)); border: 1px solid rgba(255,255,255,.08); box-shadow: 0 12px 40px rgba(0,0,0,.45), inset 0 0 12px rgba(124,220,255,.12); transform-style: preserve-3d; }
  .menu3d::before { content:""; position:absolute; inset:-1px; border-radius:inherit; background: linear-gradient(135deg, var(--rim), rgba(255,136,68,.25), rgba(72,255,167,.25)); -webkit-mask: linear-gradient(#000 0 0) content-box, linear-gradient(#000 0 0); -webkit-mask-composite: xor; mask-composite: exclude; padding:1px; pointer-events:none; opacity:.65; transform: translateZ(1px); }
  #overlayTitle { color:#38bdf8 !important; font-size:20px; letter-spacing:.06em; margin:0 0 10px; text-shadow: 0 0 8px rgba(56,189,248,.55), 0 0 18px rgba(56,189,248,.25); transform: translateZ(18px); }
  #startPanel p, #pausePanel p, #gameOverPanel p { font-size:12px; opacity:.85; margin:6px 0 12px; transform: translateZ(14px); }

  /* Difficulty tiles */
  .tiles3d { display:flex; flex-wrap:wrap; gap:8px; justify-content:center; transform-style:preserve-3d; }
  .tile3d, .choice.tile3d { position: relative; padding: 8px 12px; border-radius:10px; font-size:11px; font-weight:800; letter-spacing:.06em; text-transform:uppercase; color:#e5e7eb; background: linear-gradient(180deg,#1f2937,#0f172a); border:1px solid rgba(255,255,255,.12); transform: translateZ(12px); transition: transform .12s ease, box-shadow .2s ease, background .2s ease; }
  .tile3d::after { content:""; position:absolute; inset:0; border-radius:inherit; box-shadow: 0 10px 20px rgba(0,0,0,.35); transform: translateZ(-6px); }
  .choice:hover { background: linear-gradient(180deg,#38bdf8,#0ea5e9); color:#fff; }
  .choice.active { background: linear-gradient(180deg,#22c55e,#15803d); color:#fff; box-shadow: 0 0 12px rgba(34,197,94,.55); transform: translateZ(18px); }

  /* CTA buttons */
  .actions { display:flex; gap:10px; justify-content:center; transform-style:preserve-3d; }
  .btn.cta3d, .actions .btn.tile3d { position: relative; padding:8px 14px; border-radius:10px; font-size:12px; font-weight:900; color:#fff; background: linear-gradient(180deg,#f97316,#ea580c); border:1px solid rgba(0,0,0,.25); transform: translateZ(16px); transition: transform .1s ease, box-shadow .2s ease, filter .2s ease; }
  .btn.cta3d:hover, .actions .btn.tile3d:hover { transform: translateZ(22px); box-shadow: 0 12px 26px rgba(249,115,22,.5); }
  .btn.cta3d span, .tile3d span { pointer-events:none; }

  /* Smaller, tighter box on phones */
  @media (max-width: 720px) {
    .menu3d { padding:14px 16px; min-width:220px; }
    #overlayTitle { font-size:18px; }
    .tile3d { font-size:10px; padding:7px 10px; }
    .btn.cta3d { font-size:11px; padding:7px 12px; }
  }

  /* Respect reduced motion */
  @media (prefers-reduced-motion: reduce) { .menu3d, .menu3d * { transition: none !important; } }

  /* ===== Customize Row ===== */
  .customize{ display:grid; grid-template-columns:repeat(3,minmax(110px,1fr)); gap:8px; width:100%; max-width:520px; margin:6px auto 12px; transform:translateZ(14px); }
  .custom-label{ display:grid; gap:4px; font-size:11px; color:#94a3b8; text-transform:uppercase; letter-spacing:.06em; }
  .custom-label select{ background:linear-gradient(180deg,#1f2937,#0f172a); color:#e5e7eb; border:1px solid rgba(255,255,255,.12); border-radius:10px; padding:6px 8px; font-weight:700; font-size:12px; }
  .custom-label{ font-size: 13px; }
  .custom-label select{ font-size: 14px; padding: 8px 10px; }

  /* Bigger selects requested */
  #playerFlagSel, #enemyFlagSel { font-size:14px; line-height:1.6; padding: 6px 10px; }
  #playerFlagSel option, #enemyFlagSel option { font-size:22px; line-height:1.8; }

  /* ===== Level Select — modern 3D glass ===== */
  :root{ --glass: rgba(255,255,255,.06); --glass-2: rgba(255,255,255,.12); --ink: #0b1a27; --muted: #9fb2c6; --neon-2: #22d3ee; }
  .level-select.neo3d{ --radius: 18px; background: radial-gradient(120% 120% at 10% 10%, rgba(255,255,255,.08), rgba(255,255,255,.02) 60%) , var(--glass); backdrop-filter: blur(14px) saturate(120%); -webkit-backdrop-filter: blur(14px) saturate(120%); border: 1px solid rgba(255,255,255,.12); border-radius: var(--radius); box-shadow: 0 10px 40px rgba(0,0,0,.35), inset 0 1px 0 rgba(255,255,255,.15), 0 0 0 1px rgba(255,255,255,.04); padding: 14px; position: relative; overflow: hidden; }
  .level-select.neo3d::before{ content:""; position:absolute; inset:-2px; background: conic-gradient(from 210deg, transparent 0 35%, var(--neon) 40%, var(--neon-2) 55%, transparent 60% 100%); filter: blur(16px) saturate(140%); opacity:.35; pointer-events:none; }
  .ls-header{ display:flex; align-items:center; justify-content:space-between; gap:12px; padding:6px 6px 12px; border-bottom: 1px dashed rgba(255,255,255,.12); }
  .ls-title{display:flex; align-items:center; gap:10px; color:#e6f3ff;}
  .ls-title strong{font:700 18px/1.2 system-ui,ui-sans-serif; letter-spacing:.2px;}
  .ls-header .ico{ width:20px; height:20px; fill:none; stroke:var(--neon-2); stroke-width:1.8; opacity:.9; }
  .ls-header .ico circle{stroke:var(--neon-2);} .ls-header .ico path{stroke-linecap:round; stroke-linejoin:round}
  .ls-pages{display:flex; align-items:center; gap:8px;}
  .chip-btn{ display:grid; place-items:center; width:36px; height:36px; border-radius:12px; background: linear-gradient(180deg, rgba(255,255,255,.12), rgba(255,255,255,.04)); border: 1px solid rgba(255,255,255,.16); box-shadow: 0 8px 18px rgba(0,0,0,.35), inset 0 1px 0 rgba(255,255,255,.22); cursor:pointer; transition: transform .12s ease, box-shadow .12s ease, background .2s ease; }
  .chip-btn:hover{ transform: translateY(-1px); box-shadow: 0 10px 24px rgba(0,0,0,.42), inset 0 1px 0 rgba(255,255,255,.25);} .chip-btn:active{ transform: translateY(0); }
  .chip-btn .ico{ width:18px; height:18px; stroke:#e8f7ff; }
  .chip.meter{ padding:7px 12px; border-radius:12px; color:#e6f3ff; font:600 13px/1 system-ui; border:1px solid rgba(255,255,255,.16); background: linear-gradient(180deg, rgba(255,255,255,.08), rgba(255,255,255,.02)), radial-gradient(120% 120% at 0 0, rgba(94,234,212,.25), transparent 60%); text-shadow: 0 1px 0 rgba(0,0,0,.2); }
  .ls-grid{ display:grid; grid-template-columns: repeat(5, minmax(0,1fr)); gap:12px; padding:14px 6px; }
  @media (max-width:640px){ .ls-grid{ grid-template-columns: repeat(4, minmax(0,1fr)); } }
  .ls-grid .level-btn{ position:relative; height:64px; border-radius:16px; border:1px solid rgba(255,255,255,.18); background: linear-gradient(180deg, rgba(255,255,255,.14), rgba(255,255,255,.04)); color:#eaf6ff; font:800 18px/1 system-ui; letter-spacing:.4px; box-shadow: 0 10px 24px rgba(0,0,0,.35), inset 0 1px 0 rgba(255,255,255,.25); text-shadow: 0 1px 0 rgba(0,0,0,.25); cursor:pointer; transform-style: preserve-3d; transition: transform .12s ease, box-shadow .18s ease, border-color .18s ease, background .25s ease; }
  .ls-grid .level-btn::before{ content:""; position:absolute; inset:0; border-radius:inherit; background: radial-gradient(120% 120% at 50% 0, rgba(94,234,212,.20), transparent 60%); opacity:.65; pointer-events:none; mix-blend:screen; }
  .ls-grid .level-btn:hover{ transform: translateY(-2px) perspective(600px) rotateX(3deg); box-shadow: 0 16px 36px rgba(0,0,0,.45), 0 0 22px -6px var(--neon-2); }
  .ls-grid .level-btn:active{ transform: translateY(0); }
  .ls-grid .level-btn .level-num{ position:relative; z-index:2; }
  .ls-grid .level-btn.locked{ cursor:not-allowed; color:#a5b4c2; border-color: rgba(255,255,255,.10); filter:saturate(.6) contrast(.95); }
  .ls-grid .level-btn.locked::after{ content:""; position:absolute; inset:0; border-radius:inherit; background: repeating-linear-gradient(135deg, rgba(255,255,255,.04) 0 4px, rgba(255,255,255,0) 4px 10px); pointer-events:none; }
  .ls-grid .level-btn .lock{ position:absolute; top:8px; right:8px; width:18px; height:18px; opacity:.9; filter: drop-shadow(0 2px 4px rgba(0,0,0,.35)); }
  .ls-grid .level-btn.selected{ border-color: var(--neon-2); box-shadow: 0 18px 36px rgba(0,0,0,.5), 0 0 0 2px rgba(34,211,238,.35) inset, 0 0 22px -6px var(--neon-2); background: linear-gradient(180deg, rgba(255,255,255,.18), rgba(255,255,255,.06)), radial-gradient(120% 120% at 50% 0, rgba(34,211,238,.25), transparent 60%); }
  .ls-info{ display:flex; align-items:center; justify-content:center; gap:10px; padding:10px; color:#d5e9ff; border-top: 1px dashed rgba(255,255,255,.12); }
  .ls-info .badge{ display:inline-flex; align-items:center; gap:8px; padding:8px 12px; border-radius:12px; background: linear-gradient(180deg, rgba(255,255,255,.10), rgba(255,255,255,.03)); border:1px solid rgba(255,255,255,.16); box-shadow: inset 0 1px 0 rgba(255,255,255,.22); font:700 13px/1 system-ui; }
  .ls-info .badge .ico{ width:16px; height:16px; stroke:var(--accent); fill:none; stroke-width:1.8; }
  .ls-info .dot{ opacity:.5 }
  #levelSelect .ico{ display:block; stroke-linecap:round; stroke-linejoin:round; } #levelSelect .ico circle{ fill:none; } #levelSelect .ico path, #levelSelect .ico circle{ vector-effect: non-scaling-stroke; }
  .level-select.neo3d:hover{ transform: translateZ(0) perspective(1200px) rotateX(.6deg) rotateY(.6deg); transition: transform .25s ease; }

  /* ===== Pause / Game Over / Level Complete shared glass ===== */
  #pausePanel, #gameOverPanel, #levelCompletePanel .lc-wrap{ border:1px solid rgba(255,255,255,.16); border-radius:18px; background: radial-gradient(120% 120% at 10% 10%, rgba(255,255,255,.08), rgba(255,255,255,.02) 60%), rgba(255,255,255,.06); backdrop-filter: blur(14px) saturate(120%); -webkit-backdrop-filter: blur(14px) saturate(120%); box-shadow: 0 10px 40px rgba(0,0,0,.35), inset 0 1px 0 rgba(255,255,255,.15), 0 0 0 1px rgba(255,255,255,.04); padding:18px; }

  /* ===== Level Complete extras ===== */
  .lc-wrap { text-align:center; position:relative; overflow:hidden; }
  .lc-wrap::before{ content:""; position:absolute; inset:-2px; background: conic-gradient(from 180deg, transparent 0 35%, var(--neon) 40%, var(--neon-2) 55%, transparent 60% 100%); filter: blur(16px) saturate(140%); opacity:.35; pointer-events:none; }
  .lc-title{ font:900 22px/1.2 system-ui; margin:6px 0 6px; background: linear-gradient(90deg, #ffd88a, #fff, #ffd88a); -webkit-background-clip: text; background-clip: text; color: transparent; animation: shimmer 1.6s linear infinite; }
  .lc-sub, .lc-time{ margin:4px 0; }
  @keyframes shimmer { 0% { background-position: -200% 0; } 100% { background-position: 200% 0; } }

  /* Gift / Reward UI */
  .gift-card{ display:flex; flex-direction:column; align-items:center; gap:.75rem; padding:1rem 1.25rem; margin:.5rem auto 1rem; background:linear-gradient(180deg, rgba(255,255,255,.08), rgba(255,255,255,.03)); border:1px solid rgba(255,255,255,.14); border-radius:16px; box-shadow: 0 12px 28px rgba(0,0,0,.35), inset 0 1px 0 rgba(255,255,255,.18); backdrop-filter: blur(12px) saturate(130%); -webkit-backdrop-filter: blur(12px) saturate(130%); width:min(420px, 92%); }
  .gift-3d{ position:relative; width:100px; height:86px; transform-style:preserve-3d; animation: giftFloat 3s ease-in-out infinite; }
  @keyframes giftFloat{ 0%,100%{ transform: translateY(0) rotateX(10deg) rotateY(-10deg); } 50%{ transform: translateY(-6px) rotateX(8deg) rotateY(-6deg); } }
  .gift-box, .gift-lid{ position:absolute; inset:auto 0 0 0; margin:auto; width:100px; border-radius:10px; background:linear-gradient(180deg, #ff7b1f, #c2410c); box-shadow: inset 0 6px 10px rgba(255,255,255,.18), inset 0 -8px 20px rgba(0,0,0,.35); }
  .gift-box{ height:66px; bottom:0; }
  .gift-lid{ height:26px; bottom:60px; background:linear-gradient(180deg, #fb923c, #ea580c); border:1px solid rgba(0,0,0,.25); transform-origin:center bottom; transition: transform .35s ease, box-shadow .35s ease; }
  .gift-bow{ position:absolute; width:36px; height:36px; left:50%; transform:translateX(-50%); bottom:78px; border-radius:999px; background:radial-gradient(circle at 35% 35%, #fff, #fde68a); box-shadow: 0 6px 16px rgba(0,0,0,.35), 0 0 18px -6px rgba(255,214,94,.9); }
  .gift-card.open .gift-lid{ transform: translateY(-30px) rotateX(35deg); box-shadow: 0 10px 28px rgba(0,0,0,.45); }
  .gift-btn{ min-width: 180px; }
  .hidden{ display:none !important; }
  .gift-amount{ display:flex; flex-direction:column; align-items:center; gap:.25rem; }
  .gift-amount-burst{ font: 800 26px/1.1 system-ui, sans-serif; color:#fffbeb; letter-spacing:.5px; text-shadow: 0 2px 10px rgba(255,166,0,.65), 0 0 30px rgba(255,111,0,.35); animation: popIn .35s ease both; }
  .gift-tip{ color:#cbd5e1; opacity:.85; font-size:12px; }
  @keyframes popIn{ 0%{ transform:scale(.85); opacity:0 } 100%{ transform:scale(1); opacity:1 } }
  .home-coins { margin: 0.75rem auto 1rem; padding: 0.5rem 1rem; font: 700 18px/1.3 system-ui, sans-serif; color: #ffd700; background: linear-gradient(145deg, rgba(255,215,0,.18), rgba(255,215,0,.05)); border: 1px solid rgba(255,215,0,.3); border-radius: 12px; box-shadow: 0 4px 14px rgba(0,0,0,.35), inset 0 1px 3px rgba(255,255,255,.2); text-align: center; width: fit-content; }
  .home-coins span { color: #fff8dc; text-shadow: 0 0 8px rgba(255,215,0,.6); }

  /* ===== Orientation-specific tweaks ===== */
  /* Portrait: make HUD text a bit larger and ensure controls are reachable above the thumb zone */
  @media (orientation: portrait) {
    #hud { left: 10px; top: 10px; font-size: 11px; }
    #controls { right: 10px; top: 10px; }
    #mobile-right { right: 14px; bottom: calc(14px + env(safe-area-inset-bottom,0)); }
    #game-canvas { width: 100vw; height: 100vh; }
    .ls-grid { grid-template-columns: repeat(4, minmax(0,1fr)); }
    .customize { grid-template-columns: 1fr 1fr; }
  }

  /* Landscape: keep your existing layout but nudge the fire button slightly inward */
  @media (orientation: landscape) {
    #mobile-right { right: calc(14px + env(safe-area-inset-right,0)); bottom: calc(12px + env(safe-area-inset-bottom,0)); }
    .ls-grid { grid-template-columns: repeat(5, minmax(0,1fr)); }
    .customize { grid-template-columns: repeat(3,minmax(110px,1fr)); }
  }

  /* Very small phones */
  @media (max-width: 380px) {
    #hud .stat { min-width: 44px; font-size: 8px; padding: 2px 3px; }
    .btn { min-width: 120px; height: 46px; font-size: 13px; }
    .mc-btn { --fire-size: clamp(72px, 12vh, 112px); }
  }
</style>
</head>
<body>
<div id="game-container">
  <canvas id="game-canvas"></canvas>

  <!-- HUD -->
  <div id="hud" class="glass ui-strong ui-outline">
    <div class="row">
      <div class="stat">Score: <span id="score">0</span></div>
      <div class="stat">Kills: <span id="kills">0</span></div>
      <div class="stat">Level: <span id="level">1</span></div>
      <div class="stat">HP: <span id="hp">50</span></div>
      <div class="stat visually-hidden">Mode: <span id="modeLabel">Easy 1</span></div>
    </div>
    <div class="row visually-hidden">
      <div class="stat">Coins: <span id="coins">0</span></div>
      <div class="stat">Enemies: <span id="enemies">0</span></div>
    </div>
  </div>

  <!-- Top Controls -->
  <div id="controls" class="glass played">
    <button id="menuBtn" class="btn" aria-pressed="false">☰</button>
    <button id="restartBtn" class="btn">↻</button>
    <button id="muteBtn" class="btn" aria-pressed="false">🔈</button>
    <input id="vol" type="range" min="0" max="1" step="0.01" value="0.7" title="Volume">
  </div>

  <!-- Overlay -->
  <div id="overlay">
    <div class="box glass">
      <div class="box glass menu3d" data-tilt>
        <div class="menu3d-inner">
          <h1 id="overlayTitle" class="ui-strong">Car Fire Combat</h1>

          <div id="startPanel">
            <div id="homeCoins" class="home-coins">💰 Coins: <span id="homeCoinsValue">0</span></div>

            <!-- LEVEL SELECT (modern glass + 3D) -->
            <div id="levelSelect" class="level-select neo3d" aria-label="Level selector">
              <div class="ls-header">
                <div class="ls-title">
                  <svg viewBox="0 0 24 24" class="ico"><circle cx="12" cy="12" r="9"/><circle cx="12" cy="12" r="5"/><circle cx="12" cy="12" r="2"/></svg>
                  <strong>Select Level</strong>
                </div>
                <div class="ls-pages" role="group" aria-label="Level pages">
                  <button id="lsPrev" class="chip-btn" type="button" aria-label="Previous page">
                    <svg viewBox="0 0 24 24" class="ico"><path d="M15 6l-6 6 6 6"/></svg>
                  </button>
                  <span id="lsPageLabel" class="chip meter">1 / 50</span>
                  <button id="lsNext" class="chip-btn" type="button" aria-label="Next page">
                    <svg viewBox="0 0 24 24" class="ico"><path d="M9 6l6 6-6 6"/></svg>
                  </button>
                </div>
              </div>
              <div id="levelGrid" class="ls-grid" role="grid" aria-label="Level numbers"></div>
              <div class="ls-info" role="status" aria-live="polite">
                <span class="badge">
                  <svg viewBox="0 0 24 24" class="ico"><path d="M12 2l3 6 6 .9-4.5 4.3 1 6.3L12 17l-5.5 2.5 1-6.3L3 8.9 9 8z"/></svg>
                  Selected: <span id="lsSelected">1</span>
                </span>
                <span class="dot">•</span>
                <span class="badge">
                  <svg viewBox="0 0 24 24" class="ico"><path d="M20 7l-8 10-4-5-6 8"/></svg>
                  Goal: <span id="lsGoal">15</span> kills
                </span>
              </div>
            </div>

            <label class="switch3d">
              <input type="checkbox" id="flagModeToggle" checked>
              <span class="track" aria-hidden="true"></span>
              <span class="lbl">Enable Flags</span>
            </label>

            <!-- Customize row -->
            <div id="customizeRow" class="customize" style="text-align:center;margin-left:auto;">
              <label class="custom-label">
                <span>Player Flag</span>
                <select id="playerFlagSel"></select>
              </label>
              <label class="custom-label">
                <span>Enemy Flag</span>
                <select id="enemyFlagSel"></select>
              </label>
            </div>

            <div id="diffRow" class="tiles3d">
              <button class="choice tile3d active" data-mode="Easy 1"><span>Easy 1</span></button>
              <button class="choice tile3d" data-mode="Easy 2"><span>Easy 2</span></button>
              <button class="choice tile3d" data-mode="Easy 3"><span>Easy 3</span></button>
              <button class="choice tile3d" data-mode="Medium"><span>Medium</span></button>
              <button class="choice tile3d" data-mode="Hard"><span>Hard</span></button>
            </div>

            <div class="actions">
              <button id="startBtn" class="btn cta3d"><span>▶ Start</span></button>
            </div>
          </div>

          <div id="pausePanel" style="display:none">
            <p id="overlayInfo" class="ui-outline">Resume or Restart the game.</p>
            <div class="actions">
              <button id="resumeBtn" class="btn tile3d"><span>▶ Resume</span></button>
              <button id="overlayRestartBtn" class="btn tile3d"><span>↻ Restart</span></button>
              <button id="overlayMuteBtn" class="btn tile3d"><span>🔈 Toggle Sound</span></button>
            </div>
          </div>

          <div id="gameOverPanel" style="display:none">
            <p id="gameOverInfo" class="ui-outline">You died.</p>
            <div class="actions">
              <button id="goRestartBtn" class="btn cta3d"><span>↻ Restart</span></button>
            </div>
          </div>

          <!-- Level Complete Panel -->
          <div id="levelCompletePanel" style="display:none">
            <div class="lc-wrap">
              <!-- Gift box reward -->
              <div class="gift-card" id="giftCard">
                <div class="gift-3d">
                  <div class="gift-lid"></div>
                  <div class="gift-box"></div>
                  <div class="gift-bow"></div>
                </div>
                <button id="openGiftBtn" class="btn cta3d gift-btn"><span>🎁 Open Gift</span></button>
                <div id="giftAmountWrap" class="gift-amount hidden">
                  <div class="gift-amount-burst">+<span id="giftAmount">0</span> coins</div>
                  <small class="gift-tip">Added to your wallet</small>
                </div>
              </div>

              <h2 class="lc-title ui-strong">Level Complete!</h2>
              <p class="lc-sub ui-outline">Level <span id="lcLevel">1</span> • Goal <span id="lcGoal">12</span> kills</p>
              <p class="lc-time ui-outline">Time: <span id="lcTime">00:42</span></p>
              <div class="actions">
                <button id="nextLevelBtn" class="btn cta3d"><span>➡ Next Level</span></button>
                <button id="retryLevelBtn" class="btn tile3d"><span>↻ Replay</span></button>
                <button id="levelMenuBtn" class="btn tile3d"><span>☰ Menu</span></button>
              </div>
            </div>
          </div>

        </div>
      </div>

    </div>
  </div>

  <!-- Floating Glass Joystick (appears wherever you touch left side) -->
  <div id="joy" class="hidden">
    <div id="joyBase"></div>
    <div id="joyStick"></div>
  </div>

  <!-- Mobile Controls: RIGHT = Fire -->
  <div id="mobile-right" class="mc-wrap">
    <button id="fireBtn" class="mc-btn" aria-label="Fire"><span>🔥</span></button>
  </div>
</div>
</body>
</html>


<script>
// ---- Coins (GLOBAL) ----
const COINS_KEY = 'cfc_coins';
let coins = Number(localStorage.getItem(COINS_KEY) || 0);

function saveCoins(){
  localStorage.setItem(COINS_KEY, String(coins));
}

function updateCoinsUI(){
  const coinsEl     = document.getElementById('coins');            // in-game HUD
  const homeCoinsEl = document.getElementById('homeCoinsValue');   // home/start panel
  if (coinsEl)     coinsEl.textContent     = coins;
  if (homeCoinsEl) homeCoinsEl.textContent = coins;
}

// paint once on load (works even if one of the spans isn't on this page)
document.addEventListener('DOMContentLoaded', updateCoinsUI);
</script>


<script>
 
  // === Projectile visual helper ===
function drawFlameProjectile(x, y, vx, vy, baseSize = 8){
  const ang = Math.atan2(vy, vx);
  const len = baseSize * 2.3;
  const w   = baseSize * 0.95;

  ctx.save();
  ctx.translate(x, y);
  ctx.rotate(ang);

  // soft smoke glow
  const smoke = ctx.createRadialGradient(0, 0, 0, 0, 0, len * 0.9);
  smoke.addColorStop(0, 'rgba(255,180,60,0.25)');
  smoke.addColorStop(1, 'rgba(255,255,255,0)');
  ctx.fillStyle = smoke;
  ctx.beginPath();
  ctx.ellipse(0, 0, len * 0.9, w * 1.1, 0, 0, Math.PI * 2);
  ctx.fill();

  // flame body
  const g = ctx.createLinearGradient(-len*0.55, 0, len*0.65, 0);
  g.addColorStop(0,   '#7c2d12');
  g.addColorStop(0.25,'rgba(234,88,12,0.95)');
  g.addColorStop(0.58,'rgba(251,146,60,0.98)');
  g.addColorStop(0.78,'rgba(253,186,116,1)');
  g.addColorStop(1,   '#fffbe0');
  ctx.fillStyle = g;

  ctx.beginPath();
  ctx.moveTo(-len*0.55, -w*0.65);
  ctx.quadraticCurveTo(-len*0.15, -w*0.95, 0, -w*0.35);
  ctx.quadraticCurveTo(len*0.70, 0, 0,  w*0.35);
  ctx.quadraticCurveTo(-len*0.15,  w*0.95, -len*0.55, -w*0.65);
  ctx.closePath();
  ctx.fill();

  ctx.restore();
}

function getFlagEmoji(cc){
  if(!cc||cc.length!==2) return '🏳️';
  const a=cc[0].toUpperCase().charCodeAt(0)-65+0x1F1E6;
  const b=cc[1].toUpperCase().charCodeAt(0)-65+0x1F1E6;
  return String.fromCodePoint(a,b);
}

/* =================== Player multi-shot based on kills =================== */
let playerShots = 1; // 1 by default

function computePlayerShots(){
  // keep your old perk: +1 shot per 10 kills, capped at 6
  return Math.min(1 + Math.floor(kills / 10), 6);
}
function applyPlayerShotTier(){
  const newShots = computePlayerShots();
  if (newShots > playerShots){
    playerShots = newShots;
    createFloatingText(
      WORLD_W/2, WORLD_H*0.25,
      `${playerShots}× FIRE`, '#0b1a27', 50, 'rgba(255,255,255,.85)', 'red'
    );
  }
}

/* =================== Assets =================== */
const bgImg = new Image();
bgImg.crossOrigin = "anonymous";
bgImg.src = "bg.jpg";
let bgReady = false;
bgImg.onload = ()=>{ bgReady = true; };

/* =================== Synth =================== */
class Synth {
  constructor(){
    this.ctx=null; this.master=null; this.gain=0.7; this.muted=false;
    this.musicBus=null; this.padLP=null; this.tremLFO=null; this.tremGain=null; this.cutLFO=null;
    this.padOscs=[]; this.stingTimer=null; this.musicOn=false;
    const unlock=()=>{
      if(!this.ctx){
        this.ctx=new (window.AudioContext||window.webkitAudioContext)();
        this.master=this.ctx.createGain(); this.master.gain.value=this.muted?0:this.gain; this.master.connect(this.ctx.destination);
        this.startScaryMusic();
      }
      if(this.ctx && this.ctx.state==='suspended') this.ctx.resume();
      window.removeEventListener('pointerdown', unlock);
      window.removeEventListener('keydown', unlock);
    };
    window.addEventListener('pointerdown', unlock, {once:true});
    window.addEventListener('keydown', unlock, {once:true});
    const nextLevelBtn  = document.getElementById('nextLevelBtn');
const retryLevelBtn = document.getElementById('retryLevelBtn');
const levelMenuBtn  = document.getElementById('levelMenuBtn');

nextLevelBtn?.addEventListener('click', ()=>{
  selectedStage = Math.min(unlockedLevel, selectedStage + 1);
  localStorage.setItem('cfc_selected_level', String(selectedStage));
  startGame(); // start next stage immediately
});
const openGiftBtn = document.getElementById('openGiftBtn');
openGiftBtn?.addEventListener('click', openGift);

retryLevelBtn?.addEventListener('click', ()=>{
  startGame(); // replay same stage
});

levelMenuBtn?.addEventListener('click', ()=>{
  // go back to start menu with level grid visible
  showStart();
});

  }
  setVolume(v){ this.gain=v; if(this.master) this.master.gain.value=this.muted?0:v; }
  setMuted(m){ this.muted=m; if(this.master) this.master.gain.value=m?0:this.gain; }
  setPaused(p){ if(this.musicBus){ const t=this.ctx.currentTime; this.musicBus.gain.cancelScheduledValues(t); this.musicBus.gain.linearRampToValueAtTime(p?0.03:0.12,t+0.15);} }
  startScaryMusic(){
    if(!this.ctx||this.musicOn) return; this.musicOn=true;
    const t0=this.ctx.currentTime;
    this.musicBus=this.ctx.createGain(); this.musicBus.gain.value=0.10;
    this.tremLFO=this.ctx.createOscillator(); this.tremLFO.type='sine'; this.tremLFO.frequency.setValueAtTime(0.85,t0);
    this.tremGain=this.ctx.createGain(); this.tremGain.gain.value=0.06;
    this.tremLFO.connect(this.tremGain).connect(this.musicBus.gain); this.tremLFO.start();
    this.padLP=this.ctx.createBiquadFilter(); this.padLP.type='lowpass'; this.padLP.frequency.value=900;
    this.cutLFO=this.ctx.createOscillator(); this.cutLFO.type='sine'; this.cutLFO.frequency.setValueAtTime(0.07,t0);
    const cutDepth=this.ctx.createGain(); cutDepth.gain.value=600;
    this.cutLFO.connect(cutDepth).connect(this.padLP.frequency); this.cutLFO.start();
    const pad1=this.ctx.createOscillator(); pad1.type='sawtooth'; pad1.frequency.setValueAtTime(110,t0);
    const pad2=this.ctx.createOscillator(); pad2.type='sawtooth'; pad2.frequency.setValueAtTime(103.83,t0);
    const pad3=this.ctx.createOscillator(); pad3.type='triangle'; pad3.frequency.setValueAtTime(164.81,t0);
    const g1=this.ctx.createGain(); g1.gain.value=0.05; const g2=this.ctx.createGain(); g2.gain.value=0.04; const g3=this.ctx.createGain(); g3.gain.value=0.03;
    pad1.connect(g1).connect(this.padLP); pad2.connect(g2).connect(this.padLP); pad3.connect(g3).connect(this.padLP);
    pad1.start(t0); pad2.start(t0); pad3.start(t0); this.padOscs.push(pad1,pad2,pad3);
    this.stingTimer=setInterval(()=>{
      const now=this.ctx.currentTime;
      const f=[523.25,554.37,587.33,659.25][Math.floor(Math.random()*4)]*(Math.random()<0.5?0.5:1);
      const o=this.ctx.createOscillator(); o.type='square'; o.frequency.setValueAtTime(f,now);
      const bp=this.ctx.createBiquadFilter(); bp.type='bandpass'; bp.frequency.value=f; bp.Q.value=6;
      const eg=this.ctx.createGain(); eg.gain.setValueAtTime(0.001,now); eg.gain.linearRampToValueAtTime(0.15,now+0.03); eg.gain.exponentialRampToValueAtTime(0.001,now+0.6);
      o.connect(bp).connect(eg).connect(this.padLP); o.start(now); o.stop(now+0.62);
    }, 6000+Math.random()*3000);
    this.padLP.connect(this.musicBus).connect(this.master);
  }
  _noiseBuffer(d=0.25){ if(!this.ctx) return null; const sr=this.ctx.sampleRate,len=Math.floor(d*sr); const buf=this.ctx.createBuffer(1,len,sr),data=buf.getChannelData(0); for(let i=0;i<len;i++){ const w=Math.random()*2-1; data[i]=(data[i-1]||0)*0.98+w*0.02;} return buf; }
  _env(node,t0,a=0.001,d=0.1,s=0.6,r=0.1,peak=1){ const g=node.gain; g.cancelScheduledValues(t0); g.setValueAtTime(0.0001,t0); g.linearRampToValueAtTime(peak,t0+a); g.linearRampToValueAtTime(peak*s,t0+a+d); g.linearRampToValueAtTime(0.0001,t0+a+d+r); }
  fire(){ if(!this.ctx) return; const t=this.ctx.currentTime; const n=this.ctx.createBufferSource(); n.buffer=this._noiseBuffer(0.12);
    const hp=this.ctx.createBiquadFilter(); hp.type='highpass'; hp.frequency.value=1800; const ng=this.ctx.createGain(); this._env(ng,t,0.001,0.05,0.2,0.06,0.9); n.connect(hp).connect(ng).connect(this.master);
    const o=this.ctx.createOscillator(); o.type='square'; o.frequency.setValueAtTime(620,t); o.frequency.exponentialRampToValueAtTime(180,t+0.08);
    const og=this.ctx.createGain(); this._env(og,t,0.001,0.04,0,0.05,0.7); o.connect(og).connect(this.master);
    n.start(t); o.start(t); o.stop(t+0.12);
  }
  death(){ if(!this.ctx) return; const t=this.ctx.currentTime; const boom=this.ctx.createOscillator(); boom.type='triangle';
    boom.frequency.setValueAtTime(120,t); boom.frequency.exponentialRampToValueAtTime(60,t+0.35); const bg=this.ctx.createGain(); this._env(bg,t,0.002,0.18,0.2,0.25,1.0); boom.connect(bg).connect(this.master);
    const ns=this.ctx.createBufferSource(); ns.buffer=this._noiseBuffer(0.5); const bp=this.ctx.createBiquadFilter(); bp.type='bandpass'; bp.frequency.value=900; bp.Q.value=0.6;
    const ng=this.ctx.createGain(); this._env(ng,t,0.005,0.22,0.3,0.28,0.9); ns.connect(bp).connect(ng).connect(this.master);
    const s=this.ctx.createOscillator(); s.type='sine'; s.frequency.setValueAtTime(700,t); s.frequency.exponentialRampToValueAtTime(200,t+0.4); const sg=this.ctx.createGain(); this._env(sg,t+0.02,0.005,0.12,0.0,0.22,0.6); s.connect(sg).connect(this.master);
    boom.start(t); boom.stop(t+0.5); ns.start(t); ns.stop(t+0.55); s.start(t); s.stop(t+0.5);
  }
  hit(){ if(!this.ctx) return; const t=this.ctx.currentTime; const o=this.ctx.createOscillator(); o.type='sawtooth'; o.frequency.setValueAtTime(300,t); o.frequency.exponentialRampToValueAtTime(120,t+0.12);
    const g=this.ctx.createGain(); this._env(g,t,0.002,0.08,0.0,0.12,0.8); o.connect(g).connect(this.master); o.start(t); o.stop(t+0.18);
  }
  gameover(){ if(!this.ctx) return; const t=this.ctx.currentTime; const o=this.ctx.createOscillator(); o.type='sine'; o.frequency.setValueAtTime(220,t); o.frequency.exponentialRampToValueAtTime(80,t+0.6);
    const g=this.ctx.createGain(); this._env(g,t,0.002,0.4,0.0,0.5,0.7); o.connect(g).connect(this.master); o.start(t); o.stop(t+0.7);
  }
  coin(){ if(!this.ctx) return; const t=this.ctx.currentTime; const o=this.ctx.createOscillator(); o.type='triangle'; o.frequency.setValueAtTime(980,t); o.frequency.exponentialRampToValueAtTime(1460,t+0.1);
    const g=this.ctx.createGain(); this._env(g,t,0.001,0.05,0.0,0.1,0.6); o.connect(g).connect(this.master); o.start(t); o.stop(t+0.15);
  }
  heal(){ if(!this.ctx) return; const t=this.ctx.currentTime; const o=this.ctx.createOscillator(); o.type='sine'; o.frequency.setValueAtTime(520,t); o.frequency.setValueAtTime(640,t+0.06);
    const g=this.ctx.createGain(); this._env(g,t,0.001,0.1,0.0,0.15,0.5); o.connect(g).connect(this.master); o.start(t); o.stop(t+0.2);
  }
}
const synth=new Synth();

/* =================== UI refs =================== */
const canvas=document.getElementById('game-canvas');
const ctx=canvas.getContext('2d');
const container=document.getElementById('game-container');
const scoreEl=document.getElementById('score');
const enemiesEl=document.getElementById('enemies');
const hpEl=document.getElementById('hp');
const killsEl=document.getElementById('kills');
const levelEl=document.getElementById('level');
const modeLabel=document.getElementById('modeLabel');
const muteBtn=document.getElementById('muteBtn');
const volSlider=document.getElementById('vol');
const menuBtn=document.getElementById('menuBtn');
const restartBtn=document.getElementById('restartBtn');
const overlay=document.getElementById('overlay');
const overlayTitle=document.getElementById('overlayTitle');
const startPanel=document.getElementById('startPanel');
const pausePanel=document.getElementById('pausePanel');
const gameOverPanel=document.getElementById('gameOverPanel');
const startBtn=document.getElementById('startBtn');
const resumeBtn=document.getElementById('resumeBtn');
const overlayRestartBtn=document.getElementById('overlayRestartBtn');
const overlayMuteBtn=document.getElementById('overlayMuteBtn');
const goRestartBtn=document.getElementById('goRestartBtn');
const diffButtons=[...document.querySelectorAll('.choice')];
const fireBtn = document.getElementById('fireBtn');

/* Level Select refs */
const levelGrid = document.getElementById('levelGrid');
const lsSelected = document.getElementById('lsSelected');
const lsGoal = document.getElementById('lsGoal');
const lsPrev = document.getElementById('lsPrev');
const lsNext = document.getElementById('lsNext');
const lsPageLabel = document.getElementById('lsPageLabel');
const unlockedLevelEl = document.getElementById('unlockedLevel');
const levelPlayBtn = document.getElementById('levelPlayBtn');
const levelBackBtn = document.getElementById('levelBackBtn');

/* Joystick refs */
const joy = document.getElementById('joy');
const joyBase = document.getElementById('joyBase');
const joyStick = document.getElementById('joyStick');

let WORLD_W = 960, WORLD_H = 540;

function resizeCanvas(){
  const dpr = Math.max(1, Math.min(3, window.devicePixelRatio || 1));
  const vpW = Math.max(1, window.innerWidth);
  const vpH = Math.max(1, window.innerHeight);

  WORLD_W = vpW;
  WORLD_H = vpH;

  canvas.style.width  = vpW + 'px';
  canvas.style.height = vpH + 'px';

  const w = Math.floor(vpW * dpr);
  const h = Math.floor(vpH * dpr);
  if (canvas.width !== w || canvas.height !== h){
    canvas.width = w; canvas.height = h;
    ctx.setTransform(dpr,0,0,dpr,0,0);
  }

  player.x = Math.min(Math.max(player.x, 40), WORLD_W-40);
  player.y = Math.min(Math.max(player.y, 40), WORLD_H-40);
}
addEventListener('resize', resizeCanvas);
addEventListener('orientationchange', ()=>setTimeout(resizeCanvas, 60));
document.addEventListener('DOMContentLoaded', resizeCanvas);
setTimeout(resizeCanvas, 0);

/* =================== Game state =================== */
let enemies=[], bullets=[], enemyBullets=[], particles=[], pickups=[], shockwaves=[];
let score=0, keys={}, nowTime=0, paused=false, gameStarted=false, screenShake=0;

const DEFAULT_START_LEVEL=1;
let selectedMode='Easy 1';
let graceMs = 0;

const player={ x:480, y:270, size:52, angle:0,
  maxHP:50, hp:50, alive:true,
  vx:0, vy:0, acc:0.62, maxSpeed:5.2, friction:0.88, wheelSpin:0
};

let kills=0;
let bossActive=false, currentBoss=null;

const FIRST_BOSS_KILLS = 15;
const BOSS_INTERVAL = 15;
let nextBossAt = FIRST_BOSS_KILLS;

/* Difficulty */
const DIFF_TABLE={
  "Easy 1": { speed:0.50, spawn:1.35, damage:0.50, playerHP:50, enemyFire:[1200,2000], enemyBullet:4.0 },
  "Easy 2": { speed:0.56, spawn:1.25, damage:0.60, playerHP:45, enemyFire:[1000,1800], enemyBullet:4.2 },
  "Easy 3": { speed:0.62, spawn:1.18, damage:0.70, playerHP:40, enemyFire:[900,1600],  enemyBullet:4.4 },
  "Medium": { speed:0.70, spawn:1.05, damage:0.90, playerHP:35, enemyFire:[800,1400],  enemyBullet:4.8 },
  "Hard":   { speed:0.88, spawn:0.95, damage:1.20, playerHP:30, enemyFire:[650,1200],  enemyBullet:5.4 }
};
let DIFF={...DIFF_TABLE[selectedMode]};
diffButtons.forEach(b=>{
  b.addEventListener('click', ()=>{
    diffButtons.forEach(d=>d.classList.remove('active'));
    b.classList.add('active'); selectedMode=b.dataset.mode;
  });
});

function rand(min,max){return Math.random()*(max-min)+min}
function irand(min,max){return Math.floor(rand(min,max+1))}

/* =================== Aim helpers =================== */
function faceTowards(x, y){ player.angle = Math.atan2(y - player.y, x - player.x) + Math.PI/2; }
function enemyAtPoint(mx, my){
  for(let i = enemies.length - 1; i >= 0; i--){
    const e = enemies[i];
    const r = (e.size || 40) * 0.7;
    if (Math.hypot(mx - e.x, my - e.y) <= r) return e;
  }
  if (typeof currentBoss === 'object' && currentBoss){
    const r = currentBoss.size * 0.8;
    if (Math.hypot(mx - currentBoss.x, my - currentBoss.y) <= r) return currentBoss;
  }
  return null;
}
let giftOpened = false;

function computeGiftCoins(){
  // Balanced: random base + tiny stage bonus.
  const base = irand(8, 18);
  const stageBonus = Math.floor(selectedStage / 7); // +1 per 7 stages
  return base + stageBonus;
}

function openGift(){
  if (giftOpened) return;
  giftOpened = true;

  // Animate lid
  const card = document.getElementById('giftCard');
  const amountEl = document.getElementById('giftAmount');
  const wrapEl   = document.getElementById('giftAmountWrap');
  card?.classList.add('open');

  // Compute & apply reward
  const amt = computeGiftCoins();
  amountEl.textContent = String(amt);
  wrapEl.classList.remove('hidden');

  coins += amt;
  if (coinsEl) coinsEl.textContent = coins;
  saveCoins();

  // Audio + little celebration
  synth.coin();
  celebrateBursts(2);
}

/* =================== Floating text =================== */
function createFloatingText(x,y,text,color,fontSize=22,stroke='rgba(0,0,0,.25)', bg=null){
  const d=document.createElement('div');
  d.className='floating-text ui-strong' + (bg==='red' ? ' red' : '');
  d.style.left=x+'px'; d.style.top=y+'px';
  d.style.color=color; d.style.fontSize=fontSize+'px';
  if(bg!=='red'){ d.style.webkitTextStroke = `1px ${stroke}`; }
  d.textContent=text;
  container.appendChild(d); setTimeout(()=>d.remove(),1100);
}

/* =================== Particles, Pickups, etc. =================== */
function spawnExplosion(x,y,scale=1){
  const count=Math.floor(rand(18,30)*scale);
  for(let i=0;i<count;i++){
    particles.push({ x, y, vx:rand(-3.6,3.6)*scale, vy:rand(-3.6,3.6)*scale,
      size:rand(3,10)*scale, life:rand(24,54)*scale, hue:rand(12,48), type: Math.random()<0.25?'spark':'fire' });
  }
  shockwaves.push({x,y,r:8,vr:7*scale,alpha:0.9*scale});
  screenShake = Math.max(screenShake, 12*scale);
}
function drawParticles(){
  for(let i=particles.length-1;i>=0;i--){
    const p=particles[i];
    if(p.type==='spark'){
      ctx.globalCompositeOperation='lighter';
      ctx.strokeStyle=`hsla(${p.hue},100%,60%,${Math.max(0,p.life/60)})`;
      ctx.lineWidth=2; ctx.beginPath();
      ctx.moveTo(p.x, p.y); ctx.lineTo(p.x - p.vx*2, p.y - p.vy*2);
      ctx.stroke();
      ctx.globalCompositeOperation='source-over';
    }else{
      const g=ctx.createRadialGradient(p.x,p.y,0,p.x,p.y,Math.max(1,p.size));
      g.addColorStop(0,'rgba(255,240,180,0.95)');
      g.addColorStop(0.35,'rgba(255,170,20,0.85)');
      g.addColorStop(0.8,'rgba(160,30,0,0.55)');
      g.addColorStop(1,'rgba(40,20,0,0.0)');
      ctx.fillStyle=g; ctx.beginPath(); ctx.arc(p.x,p.y,Math.max(1,p.size),0,Math.PI*2); ctx.fill();
    }
    p.x+=p.vx; p.y+=p.vy; p.size*=0.96; p.life--;
    if(p.life<=0 || p.size<0.6) particles.splice(i,1);
  }
  for(let i=shockwaves.length-1;i>=0;i--){
    const s=shockwaves[i];
    ctx.beginPath(); ctx.strokeStyle=`rgba(0,0,0,${s.alpha*0.6})`;
    ctx.lineWidth=3; ctx.arc(s.x,s.y,s.r,0,Math.PI*2); ctx.stroke();
    s.r+=s.vr; s.alpha*=0.88;
    if(s.alpha<0.04) shockwaves.splice(i,1);
  }
  ctx.globalAlpha=1;
}
class Pickup{
  constructor(x,y,type='health'){ this.x=x; this.y=y; this.r=12; this.type=type; this.life=7000; }
  update(dt){ this.life-=dt; return this.life>0; }
  draw(){ ctx.save(); ctx.translate(this.x,this.y);
    if(this.type==='health'){ ctx.fillStyle='#10b981'; ctx.beginPath(); ctx.arc(0,0,this.r,0,Math.PI*2); ctx.fill();
      ctx.fillStyle='#065f46'; ctx.fillRect(-3,-8,6,16); ctx.fillRect(-8,-3,16,6); }
    ctx.restore();
  }
}
function isOnScreen(x,y,margin=0){ return x>-margin && x<WORLD_W+margin && y>-margin && y<WORLD_H+margin; }

/* =================== Tank + flags (unchanged drawing helpers) =================== */
const PLAYER_COLORS = { bodyA:'#475569', bodyB:'#1f2937', track:'#0f172a', accent:(getComputedStyle(document.documentElement).getPropertyValue('--accent') || '#ff7b1f').trim() };
const ENEMY_COLORS  = { bodyA:'#64748b', bodyB:'#334155', track:'#0f172a', accent:'#fb923c' };
const FLAG_SPRITE_CACHE = Object.create(null);
function ccToRegionalHex(cc){
  if(!cc || cc.length!==2) return null;
  const A = 'A'.charCodeAt(0);
  const cp1 = 0x1F1E6 + (cc[0].toUpperCase().charCodeAt(0) - A);
  const cp2 = 0x1F1E6 + (cc[1].toUpperCase().charCodeAt(0) - A);
  return cp1.toString(16) + '-' + cp2.toString(16);
}
function getFlagSprite(cc, onReady){
  const hex = ccToRegionalHex(cc);
  if(!hex){ onReady(null); return; }
  if(FLAG_SPRITE_CACHE[hex] === 'loading'){ setTimeout(()=>getFlagSprite(cc, onReady), 30); return; }
  const cached = FLAG_SPRITE_CACHE[hex];
  if(cached && cached.complete){ onReady(cached); return; }
  FLAG_SPRITE_CACHE[hex] = 'loading';
  const img = new Image();
  img.crossOrigin = 'anonymous';
  img.src = `https://cdnjs.cloudflare.com/ajax/libs/twemoji/14.0.2/72x72/${hex}.png`;
  img.onload = ()=>{ FLAG_SPRITE_CACHE[hex] = img; onReady(img); };
  img.onerror = ()=>{ FLAG_SPRITE_CACHE[hex] = null; onReady(null); };
}
function paintFallbackFlagPlate(ctx, s, cc){
  const w = s * 0.90, h = s * 0.60, r = Math.max(4, s*0.06);
  const x = -w/2, y = -h/2;
  if(!ctx.roundRect){
    ctx.beginPath();
    ctx.moveTo(x+r,y); ctx.lineTo(x+w-r,y); ctx.quadraticCurveTo(x+w,y,x+w,y+r);
    ctx.lineTo(x+w,y+h-r); ctx.quadraticCurveTo(x+w,y+h,x+w-r,y+h);
    ctx.lineTo(x+r,y+h); ctx.quadraticCurveTo(x,y+h,x,y+h-r);
    ctx.lineTo(x,y+r); ctx.quadraticCurveTo(x,y,x+r,y); ctx.closePath();
    ctx.fillStyle = '#fff'; ctx.fill(); ctx.strokeStyle='rgba(0,0,0,.15)'; ctx.stroke();
  } else {
    ctx.fillStyle = '#fff'; ctx.roundRect(x,y,w,h,r); ctx.fill();
    ctx.strokeStyle='rgba(0,0,0,.15)'; ctx.stroke();
  }
  ctx.fillStyle = '#d1d5db'; ctx.fillRect(x, y, w/3, h);
  ctx.fillStyle = '#9ca3af'; ctx.fillRect(x+w/3, y, w/3, h);
  ctx.fillStyle = '#6b7280'; ctx.fillRect(x+2*w/3, y, w/3, h);
  ctx.fillStyle = '#111827';
  ctx.font = `900 ${Math.max(12, Math.floor(s*0.18))}px system-ui, Arial`;
  ctx.textAlign='center'; ctx.textBaseline='middle';
  ctx.fillText((cc||'--').toUpperCase(), 0, 0);
}
function drawFlagDecal(ctx, s, cc){
  getFlagSprite(cc, (img)=>{
    ctx.save();
    const W = s * 0.8, H = s * 1.5;
    const x = -W/2, y = -H/2;
    if(img){
      ctx.shadowColor = 'rgba(0,0,0,0.30)';
      ctx.shadowBlur = Math.max(2, s*0.06);
      ctx.drawImage(img, x, y, W, H);
      ctx.shadowBlur = 0;
    }else{
      paintFallbackFlagPlate(ctx, s, cc);
    }
    ctx.restore();
  });
}
function drawWheel(x,y,r,spin){
  ctx.save(); ctx.translate(x,y);
  ctx.fillStyle='#111827'; ctx.beginPath(); ctx.arc(0,0,r,0,Math.PI*2); ctx.fill();
  ctx.fillStyle='#374151'; ctx.beginPath(); ctx.arc(0,0,r*0.72,0,Math.PI*2); ctx.fill();
  ctx.strokeStyle='#111827'; ctx.lineWidth=2; ctx.rotate(spin);
  for(let i=0;i<6;i++){ ctx.beginPath(); ctx.moveTo(-r*0.8,0); ctx.lineTo(r*0.8,0); ctx.stroke(); ctx.rotate(Math.PI/3); }
  ctx.fillStyle='#9ca3af'; ctx.beginPath(); ctx.arc(0,0,r*0.28,0,Math.PI*2); ctx.fill();
  ctx.restore();
}
function drawTank(x, y, size, hullAngle, wheelSpin, colors, turretAngle=null){
  const s = size;
  ctx.save();
  ctx.translate(x, y);
  ctx.rotate(hullAngle);
  ctx.fillStyle='rgba(0,0,0,0.10)';
  ctx.beginPath(); ctx.ellipse(0, s*0.6, s*0.9, s*0.4, 0, 0, Math.PI*2); ctx.fill();
  const wR = s*0.16;
  drawWheel(-s*0.48, -s*0.45, wR, wheelSpin);
  drawWheel( s*0.48, -s*0.45, wR, wheelSpin);
  drawWheel(-s*0.48,  s*0.45, wR, wheelSpin);
  drawWheel( s*0.48,  s*0.45, wR, wheelSpin);
  const trackW=s*0.26, trackH=s*1.05;
  ctx.fillStyle=colors.track;
  ctx.fillRect(-s*0.65,-trackH/2,trackW,trackH);
  ctx.fillRect( s*0.39,-trackH/2,trackW,trackH);
  ctx.fillStyle='rgba(255,255,255,0.08)';
  for(let i=-6;i<6;i++){
    ctx.fillRect(-s*0.65,i*(s*0.18)-trackH/2+s*0.1,trackW,s*0.06);
    ctx.fillRect( s*0.39,i*(s*0.18)-trackH/2+s*0.1,trackW,s*0.06);
  }
  const hullGrad=ctx.createLinearGradient(-s*0.8,-s*0.8,s*0.8,s*0.8);
  hullGrad.addColorStop(0,colors.bodyA);
  hullGrad.addColorStop(1,colors.bodyB);
  ctx.fillStyle=hullGrad;
  ctx.beginPath();
  ctx.moveTo(-s*0.5,-s*0.35);
  ctx.lineTo(s*0.4,-s*0.45);
  ctx.lineTo(s*0.6,0);
  ctx.lineTo(s*0.4,s*0.45);
  ctx.lineTo(-s*0.5,s*0.35);
  ctx.closePath();
  ctx.fill();
  ctx.lineWidth=3;
  ctx.strokeStyle=colors.accent;
  ctx.beginPath(); ctx.moveTo(-s*0.35,-s*0.25); ctx.lineTo(s*0.25,-s*0.32); ctx.stroke();
  const gg=ctx.createLinearGradient(-s*0.1,-s*0.25,s*0.1,s*0.25);
  gg.addColorStop(0,'rgba(10,200,255,0.25)');
  gg.addColorStop(1,'rgba(10,200,255,0.10)');
  ctx.fillStyle=gg; ctx.beginPath(); ctx.ellipse(0,-s*0.05,s*0.22,s*0.14,0,0,Math.PI*2); ctx.fill();
  ctx.fillStyle='#0f1720';
  if(!CanvasRenderingContext2D.prototype.roundRect){ ctx.fillRect(-6,-s*0.95,12,s*0.6) } else { ctx.roundRect(-6,-s*0.95,12,s*0.6,6); ctx.fill(); }
  ctx.shadowColor='#fff8b8'; ctx.shadowBlur=18; ctx.fillStyle='#fff6b0';
  ctx.beginPath(); ctx.ellipse(-s*0.32,-s*0.38,6,6,0,0,Math.PI*2); ctx.fill();
  ctx.beginPath(); ctx.ellipse( s*0.32,-s*0.38,6,6,0,0,Math.PI*2); ctx.fill();
  ctx.shadowBlur=0;
  ctx.restore();
  if (turretAngle != null){
    ctx.save();
    ctx.translate(x, y); ctx.rotate(turretAngle);
    ctx.fillStyle='rgba(0,0,0,0.25)';
    if(!CanvasRenderingContext2D.prototype.roundRect){ ctx.fillRect(-s*0.20,-s*0.22,s*0.40,s*0.34); }
    else { ctx.roundRect(-s*0.20,-s*0.22,s*0.40,s*0.34,10); ctx.fill(); }
    ctx.fillStyle='#0f172a';
    if(!CanvasRenderingContext2D.prototype.roundRect){ ctx.fillRect(s*0.18,-s*0.05,s*0.46,s*0.10); }
    else { ctx.roundRect(s*0.18,-s*0.05,s*0.46,s*0.10,6); ctx.fill(); }
    const flagMode = (localStorage.getItem("cfc_flag_mode") || "on") === "on";
    if(flagMode){
      const cc = (colors === PLAYER_COLORS)
        ? (localStorage.getItem('cfc_player_flag') || 'US')
        : (localStorage.getItem('cfc_enemy_flag')  || 'IN');
      drawFlagDecal(ctx, s, cc);
    }
    ctx.fillStyle=colors.accent;
    ctx.beginPath(); ctx.ellipse(s*0.70,0,s*0.06,s*0.06,0,0,Math.PI*2); ctx.fill();
    ctx.restore();
  }
}

/* =================== Enemies & Bullets =================== */
class Enemy{
  constructor(){
    this.size=rand(28,56);
    this.maxHealth=Math.max(1,Math.ceil(this.size/10));
    this.health=this.maxHealth;
    const edge=Math.floor(rand(0,4));
    if(edge===0){ this.x=-this.size; this.y=rand(0,WORLD_H);}
    else if(edge===1){ this.x=WORLD_W+this.size; this.y=rand(0,WORLD_H);}
    else if(edge===2){ this.x=rand(0,WORLD_W); this.y=-this.size;}
    else { this.x=rand(0,WORLD_W); this.y=WORLD_H+this.size; }
    this.speed=((rand(0.5,1.25)+(this.size/240))*(1+(selectedStage-1)*0.05))*0.55*DIFF.speed;
    this.hitTimer=0; this.turretAngle=0; this.sinceShot=0;
    const [minF,maxF]=DIFF.enemyFire;
    this.shootDelay=rand(minF,maxF)/(1+(selectedStage-1)*0.05);
  }
  update(dt){
    const dx=player.x-this.x, dy=player.y-this.y, d=Math.hypot(dx,dy)||1;
    this.x+=(dx/d)*this.speed*(1+Math.sin(nowTime/300+this.size)*0.02);
    this.y+=(dy/d)*this.speed*(1+Math.cos(nowTime/300+this.size)*0.02);
    this.turretAngle=Math.atan2(player.y-this.y, player.x-this.x);
    this.sinceShot+=dt;
    if(graceMs===0 && this.sinceShot>=this.shootDelay && player.alive && isOnScreen(this.x,this.y,0)){
      this.sinceShot=0;
      const [minF,maxF]=DIFF.enemyFire;
      this.shootDelay=rand(minF,maxF)/(1+(selectedStage-1)*0.05);
      enemyBullets.push(new EnemyBullet(this.x,this.y,player.x,player.y,this.turretAngle));
    }
    if(this.hitTimer>0) this.hitTimer-=dt;
  }
  draw(){
    const s=this.size;
    const enemySpin = nowTime * 0.002 * (2 + this.speed * 10);
    const hullAngle = this.turretAngle + Math.PI/2;
    drawTank(this.x, this.y, s, hullAngle, enemySpin, ENEMY_COLORS, this.turretAngle);
    const textScale=1+((this.hitTimer>0?0.25:0)*Math.min(1,this.hitTimer/120));
    ctx.save();
    ctx.fillStyle='#0b1a27';
    ctx.font=`900 ${Math.max(12,s*0.45*textScale)}px system-ui, Arial`;
    ctx.textAlign='center'; ctx.textBaseline='middle';
    ctx.fillText(this.health,this.x,this.y);
    ctx.restore();
  }
}
class EnemyBullet{
  constructor(x,y,tx,ty,angle){
    this.x=x; this.y=y; this.size=6; this.speed=DIFF.enemyBullet+(selectedStage-1)*0.06;
    const dx=tx-x,dy=ty-y,d=Math.hypot(dx,dy)||1; this.vx=dx/d*this.speed; this.vy=dy/d*this.speed; this.angle=angle||Math.atan2(dy,dx);
    this.trail=0;
  }
  update(){
    this.x+=this.vx; this.y+=this.vy; this.trail+=Math.hypot(this.vx,this.vy);
    if(this.trail>22){ this.trail=0; particles.push({x:this.x, y:this.y, vx:rand(-0.6,0.6), vy:rand(0.2,1), size:rand(1.2,2.2), life:rand(10,20), hue:rand(15,35), type:'fire'}); }
    return this.x>-60&&this.x<WORLD_W+60&&this.y>-60&&this.y<WORLD_H+60;
  }
  draw(){ drawFlameProjectile(this.x,this.y,this.vx,this.vy,this.size); }
}
class Bullet{
  constructor(x,y,tx,ty){
    this.x=x; this.y=y; this.size=12; this.speed=14;
    const dx=tx-x,dy=ty-y,d=Math.hypot(dx,dy)||1; this.vx=dx/d*this.speed; this.vy=dy/d*this.speed; this.damage=2;
    this.trail=0;
  }
  update(){
    this.x+=this.vx; this.y+=this.vy;
    this.trail+=Math.hypot(this.vx,this.vy);
    if(this.trail>18){ this.trail=0; particles.push({x:this.x, y:this.y, vx:rand(-0.7,0.7), vy:rand(-0.5,0.5), size:rand(1.6,3.0), life:rand(14,26), hue:rand(15,35), type:'fire'}); }
    return this.x>-50&&this.x<WORLD_W+50&&this.y>-50&&this.y<WORLD_H+50;
  }
  draw(){ drawFlameProjectile(this.x,this.y,this.vx,this.vy,this.size); }
}

/* =================== Player =================== */
function handlePlayerMovement(){
  if(!player.alive||paused||!gameStarted) return;
  let ax=0, ay=0;
  if(keys['w']||keys['arrowup']) ay-=player.acc;
  if(keys['s']||keys['arrowdown']) ay+=player.acc;
  if(keys['a']||keys['arrowleft']) ax-=player.acc;
  if(keys['d']||keys['arrowright']) ax+=player.acc;
  if(joyMag>0){
    ax += joyVec.x * player.acc * 1.4;
    ay += joyVec.y * player.acc * 1.4;
    if(joyMag>0.05){
      const ex = player.x - joyVec.x*28, ey = player.y - joyVec.y*28;
      particles.push({x: ex, y: ey, vx: rand(-0.6,0.6)-joyVec.x*0.8, vy: rand(-0.6,0.6)-joyVec.y*0.8, size: rand(2,4)+joyMag*2, life: rand(12,22), hue: rand(40,60), type:'fire'});
    }
  }
  player.vx=(player.vx+ax)*player.friction;
  player.vy=(player.vy+ay)*player.friction;
  const sp=Math.hypot(player.vx,player.vy);
  const top = player.maxSpeed + 2.4*joyMag;
  if(sp>top){ player.vx*=top/sp; player.vy*=top/sp; }
  player.x+=player.vx; player.y+=player.vy;
  player.wheelSpin += sp * 0.15;
  if(joyMag>0.01){
    if(player.vx!==0 || player.vy!==0){
      player.angle = Math.atan2(player.vy, player.vx) + Math.PI/2;
    }
  }
  const pad=40;
  if(player.x<pad){ player.x=pad; player.vx*=-0.3; }
  if(player.x>WORLD_W-pad){ player.x=WORLD_W-pad; player.vx*=-0.3; }
  if(player.y<pad){ player.y=pad; player.vy*=-0.3; }
  if(player.y>WORLD_H-pad){ player.y=WORLD_H-pad; player.vy*=-0.3; }
}
function drawPlayer(){
  drawTank(player.x, player.y, player.size, player.angle, player.wheelSpin, PLAYER_COLORS, player.angle - Math.PI/2);
}
if(!CanvasRenderingContext2D.prototype.roundRect){CanvasRenderingContext2D.prototype.roundRect=function(x,y,w,h,r){if(typeof r==='undefined') r=4;this.beginPath();this.moveTo(x+r,y);this.arcTo(x+w,y,x+w,y+h,r);this.arcTo(x+w,y+h,x,y+h,r);this.arcTo(x,y+h,x,y,r);this.arcTo(x,y,x+w,y,r);this.closePath();return this;}}

/* =================== Input =================== */
canvas.addEventListener('mousemove', e=>{
  const r=canvas.getBoundingClientRect(); const mx=e.clientX-r.left,my=e.clientY-r.top;
  player.angle=Math.atan2(my-player.y,mx-player.x)+Math.PI/2;
});
function shootToward(mx, my){
  const aim = Math.atan2(my - player.y, mx - player.x);
  const shots = playerShots;
  if (shots <= 1){
    bullets.push(new Bullet(player.x, player.y, mx, my));
    synth.fire();
    return;
  }
  const TOTAL_SPREAD = Math.min(0.28, 0.10 * (shots - 1));
  const step = (shots === 1) ? 0 : (TOTAL_SPREAD / (shots - 1));
  const start = aim - TOTAL_SPREAD / 2;
  for (let i = 0; i < shots; i++){
    const a = start + step * i;
    const tx = player.x + Math.cos(a) * 200;
    const ty = player.y + Math.sin(a) * 200;
    bullets.push(new Bullet(player.x, player.y, tx, ty));
  }
  synth.fire();
}
canvas.addEventListener('click', e=>{
  if(!gameStarted){ return; }
  if(!player.alive){ restart(); return; }
  if(paused){ togglePause(false); return; }
  const r = canvas.getBoundingClientRect();
  const mx = e.clientX - r.left;
  const my = e.clientY - r.top;
  const hit = enemyAtPoint(mx, my);
  if (hit){ faceTowards(hit.x, hit.y); return; }
  shootToward(mx, my);
});

/* Floating Glass Joystick */
let joyActive=false, joyPID=null, joyStart={x:0,y:0}, joyVec={x:0,y:0}, joyMag=0;
const JOY_MAX = 80;
function showJoy(cx,cy){
  joy.classList.remove('hidden');
  joyBase.style.left = cx+'px'; joyBase.style.top = cy+'px';
  joyStick.style.left = cx+'px'; joyStick.style.top = cy+'px';
}
function moveJoy(cx,cy){
  const dx = cx - joyStart.x, dy = cy - joyStart.y;
  const dist = Math.hypot(dx,dy);
  const cl = Math.min(JOY_MAX, dist);
  const nx = (dx/(dist||1))*cl, ny = (dy/(dist||1))*cl;
  joyStick.style.left = (joyStart.x + nx) + 'px';
  joyStick.style.top  = (joyStart.y + ny) + 'px';
  joyMag = Math.min(1, dist/JOY_MAX);
  joyVec.x = (dx/(dist||1))*joyMag;
  joyVec.y = (dy/(dist||1))*joyMag;
}
function hideJoy(){ joy.classList.add('hidden'); joyActive=false; joyPID=null; joyMag=0; joyVec.x=0; joyVec.y=0; }
canvas.addEventListener('pointerdown', e=>{
  if(!gameStarted || paused || !player.alive) return;
  const rect = canvas.getBoundingClientRect();
  const mx = e.clientX - rect.left;
  const my = e.clientY - rect.top;
  const hit = enemyAtPoint(mx, my);
  if (hit){ e.preventDefault(); faceTowards(hit.x, hit.y); return; }
  if(e.pointerType==='mouse'){ return; }
  if(mx <= rect.width*0.60){
    e.preventDefault();
    const crect = container.getBoundingClientRect();
    joyActive=true; joyPID=e.pointerId;
    joyStart.x = e.clientX - crect.left; joyStart.y = e.clientY - crect.top;
    showJoy(joyStart.x, joyStart.y);
    moveJoy(joyStart.x, joyStart.y);
    canvas.setPointerCapture(e.pointerId);
  }else{
    player.angle = Math.atan2(my-player.y, mx-player.x)+Math.PI/2;
    shootToward(mx,my);
  }
});
canvas.addEventListener('pointermove', e=>{
  if(joyActive && e.pointerId===joyPID){
    e.preventDefault();
    const crect = container.getBoundingClientRect();
    moveJoy(e.clientX - crect.left, e.clientY - crect.top);
  }
});
function endJoy(e){
  if(e.pointerId===joyPID){
    e.preventDefault();
    hideJoy();
    try{ canvas.releasePointerCapture(e.pointerId); }catch(_){}
  }
}
canvas.addEventListener('pointerup', endJoy);
canvas.addEventListener('pointercancel', endJoy);

/* Keyboard pause/restart */
window.addEventListener('keydown', e=>{
  keys[e.key.toLowerCase()] = true;
  if(e.key==='Escape' && gameStarted) togglePause(!paused);
  if(!player.alive && e.key===' ') restart();
});
window.addEventListener('keyup', e=> keys[e.key.toLowerCase()] = false);

menuBtn.addEventListener('click', ()=> { if(gameStarted) togglePause(!paused); else showStart(); });
restartBtn.addEventListener('click', ()=> restart());
resumeBtn?.addEventListener('click', ()=> togglePause(false));
overlayRestartBtn?.addEventListener('click', ()=> { togglePause(false); restart(); });
overlayMuteBtn?.addEventListener('click', ()=> muteBtn.click());
goRestartBtn?.addEventListener('click', ()=> { showStart(); });
startBtn.addEventListener('click', ()=> startGame());

/* ===== FIRE glass button ===== */
let fireInterval=null;
function fireForward(){
  if(!gameStarted || paused || !player.alive) return;
  const aim = player.angle - Math.PI/2;
  const shots = playerShots;
  if (shots <= 1){
    const tx = player.x + Math.cos(aim)*200;
    const ty = player.y + Math.sin(aim)*200;
    bullets.push(new Bullet(player.x, player.y, tx, ty));
    synth.fire();
    return;
  }
  const TOTAL_SPREAD = Math.min(0.28, 0.10 * (shots - 1));
  const step = (shots === 1) ? 0 : (TOTAL_SPREAD / (shots - 1));
  const start = aim - TOTAL_SPREAD / 2;
  for (let i = 0; i < shots; i++){
    const a = start + step * i;
    const tx = player.x + Math.cos(a) * 200;
    const ty = player.y + Math.sin(a) * 200;
    bullets.push(new Bullet(player.x, player.y, tx, ty));
  }
  synth.fire();
}
fireBtn.addEventListener('pointerdown', e=>{
  fireBtn.setPointerCapture(e.pointerId);
  fireForward();
  if(fireInterval) clearInterval(fireInterval);
  fireInterval=setInterval(fireForward, 180);
});
function endFire(e){
  if(fireInterval){ clearInterval(fireInterval); fireInterval=null; }
  try{ fireBtn.releasePointerCapture(e.pointerId); }catch(_){}
}
fireBtn.addEventListener('pointerup', endFire);
fireBtn.addEventListener('pointercancel', endFire);
fireBtn.addEventListener('click', fireForward);

/* =================== Volume/Mute =================== */
muteBtn.addEventListener('click', ()=>{
  const pressed=muteBtn.getAttribute('aria-pressed')==='true';
  const newState=!pressed;
  muteBtn.setAttribute('aria-pressed', String(newState));
  muteBtn.classList.toggle('active', newState);
  muteBtn.textContent=newState?'🔇':'🔈';
  synth.setMuted(newState);
});
volSlider.addEventListener('input', e=> synth.setVolume(parseFloat(e.target.value||'0.7')));

/* =================== Loop & Update =================== */
let last=performance.now(); let spawnTimer=0;
function spawnInterval(){ const base=2000; return base * Math.pow(0.92, Math.max(0,selectedStage-1)) * DIFF.spawn; }

/* ======== Boss visuals (unchanged helpers) ======== */
const BOSS_PALETTES = {
  azure:{fuselageA:'#0ea5e9',fuselageB:'#0369a1',wing:'#075985',stripe:'#67e8f9',glow:'#22d3ee',canopy1:'rgba(200,240,255,0.4)',canopy2:'rgba(200,240,255,0.12)'},
  scarlet:{fuselageA:'#ef4444',fuselageB:'#7f1d1d',wing:'#991b1b',stripe:'#fecaca',glow:'#fca5a5',canopy1:'rgba(255,230,230,0.4)',canopy2:'rgba(255,230,230,0.12)'},
  midnight:{fuselageA:'#7c3aed',fuselageB:'#1e1b4b',wing:'#312e81',stripe:'#c4b5fd',glow:'#a78bfa',canopy1:'rgba(230,220,255,0.4)',canopy2:'rgba(230,220,255,0.12)'},
  inferno:{fuselageA:'#ff7b1f',fuselageB:'#7a2200',wing:'#4a1c00',stripe:'#ffd085',glow:'#ffb86b',canopy1:'rgba(255,220,180,0.4)',canopy2:'rgba(255,220,180,0.12)'}
};
function drawAirBoss(x, y, s, hullAngle, turretAngle, theme, t=0){
  const pulse = 0.6 + 0.4*Math.sin(t*0.006);
  const thr   = 0.75 + 0.25*Math.sin(t*0.03);
  ctx.save(); ctx.translate(x, y); ctx.rotate(hullAngle);
  ctx.fillStyle='rgba(0,0,0,0.22)'; ctx.beginPath(); ctx.ellipse(0, s*0.58, s*1.05, s*0.42, 0, 0, Math.PI*2); ctx.fill();
  const fus = ctx.createLinearGradient(-s*0.95, -s*0.44, s*0.95, s*0.44);
  fus.addColorStop(0, theme.fuselageA); fus.addColorStop(1, theme.fuselageB); ctx.fillStyle = fus;
  if(!CanvasRenderingContext2D.prototype.roundRect){ ctx.beginPath(); ctx.moveTo(-s*0.9,-s*0.30); ctx.quadraticCurveTo(0,-s*0.50, s*0.75,-s*0.24); ctx.lineTo(s*0.95, 0); ctx.quadraticCurveTo(0, s*0.50, -s*0.9, s*0.30); ctx.closePath(); ctx.fill(); }
  else { ctx.roundRect(-s*0.88, -s*0.28, s*1.76, s*0.56, s*0.22); ctx.fill(); }
  ctx.fillStyle = theme.fuselageB; ctx.beginPath(); ctx.moveTo(s*0.95, 0); ctx.lineTo(s*1.10, -s*0.08); ctx.lineTo(s*1.10,  s*0.08); ctx.closePath(); ctx.fill();
  ctx.lineWidth = Math.max(1.5, s*0.012); ctx.strokeStyle = 'rgba(255,255,255,0.10)';
  for(let i=-3;i<=3;i++){ const yy = i*(s*0.07); ctx.beginPath(); ctx.moveTo(-s*0.65, yy); ctx.lineTo( s*0.55, yy*0.85); ctx.stroke(); }
  ctx.fillStyle = theme.wing;
  ctx.beginPath(); ctx.moveTo(-s*0.10, -s*0.22); ctx.lineTo(-s*1.05, -s*0.62); ctx.lineTo(-s*0.40, -s*0.04); ctx.closePath(); ctx.fill();
  ctx.beginPath(); ctx.moveTo(-s*0.10,  s*0.22); ctx.lineTo(-s*1.05,  s*0.62); ctx.lineTo(-s*0.40,  s*0.04); ctx.closePath(); ctx.fill();
  ctx.fillStyle = theme.fuselageB;
  ctx.beginPath(); ctx.moveTo(-s*1.02, -s*0.62); ctx.lineTo(-s*1.18, -s*0.52); ctx.lineTo(-s*0.94, -s*0.50); ctx.closePath(); ctx.fill();
  ctx.beginPath(); ctx.moveTo(-s*1.02,  s*0.62); ctx.lineTo(-s*1.18,  s*0.52); ctx.lineTo(-s*0.94,  s*0.50); ctx.closePath(); ctx.fill();
  ctx.save(); ctx.rotate(-0.012); ctx.fillStyle = theme.fuselageB; ctx.beginPath(); ctx.moveTo(-s*0.78, -s*0.12); ctx.lineTo(-s*0.54,  0); ctx.lineTo(-s*0.78,  s*0.12); ctx.closePath(); ctx.fill(); ctx.restore();
  ctx.strokeStyle = theme.stripe; ctx.lineWidth = Math.max(2, s*0.02);
  ctx.beginPath(); ctx.moveTo(-s*0.70,-s*0.14); ctx.quadraticCurveTo(0,-s*0.26, s*0.62,-s*0.18); ctx.stroke();
  ctx.beginPath(); ctx.moveTo(-s*0.70, s*0.14); ctx.quadraticCurveTo(0, s*0.26, s*0.62, s*0.18); ctx.stroke();
  const glass = ctx.createLinearGradient(-s*0.12,-s*0.20, s*0.12, s*0.20);
  glass.addColorStop(0, theme.canopy1); glass.addColorStop(1, theme.canopy2);
  ctx.fillStyle = glass; ctx.beginPath(); ctx.ellipse(s*0.12, -s*0.03, s*0.34, s*0.18, 0, 0, Math.PI*2); ctx.fill();
  function engineGlow(ex,ey,rx,ry){
    const eg = ctx.createRadialGradient(ex,ey,0, ex,ey, rx*2.8*thr);
    eg.addColorStop(0,'#ffffff'); eg.addColorStop(0.35, theme.glow); eg.addColorStop(1,'rgba(255,255,255,0)');
    ctx.fillStyle = eg; ctx.beginPath(); ctx.ellipse(ex,ey, rx*3.2, ry*1.8, 0, 0, Math.PI*2); ctx.fill();
  }
  engineGlow(-s*0.40, -s*0.14, s*0.13, s*0.09); engineGlow(-s*0.40,  s*0.14, s*0.13, s*0.09);
  ctx.fillStyle = theme.stripe; ctx.beginPath(); ctx.ellipse(s*1.06, 0, s*0.045*pulse, s*0.045*pulse, 0, 0, Math.PI*2); ctx.fill();
  ctx.restore();

  ctx.save(); ctx.translate(x, y); ctx.rotate(turretAngle);
  ctx.fillStyle = '#0f172a';
  if(!CanvasRenderingContext2D.prototype.roundRect){
    ctx.fillRect(s*0.22, -s*0.11, s*0.70, s*0.12);
    ctx.fillRect(s*0.22, -s*0.26, s*0.56, s*0.08);
    ctx.fillRect(s*0.22,  s*0.00, s*0.70, s*0.12);
    ctx.fillRect(s*0.22,  s*0.18, s*0.56, s*0.08);
  } else {
    ctx.roundRect(s*0.22, -s*0.11, s*0.70, s*0.12, 8); ctx.fill();
    ctx.roundRect(s*0.22, -s*0.26, s*0.56, s*0.08, 6); ctx.fill();
    ctx.roundRect(s*0.22,  s*0.00, s*0.70, s*0.12, 8); ctx.fill();
    ctx.roundRect(s*0.22,  s*0.18, s*0.56, s*0.08, 6); ctx.fill();
  }
  ctx.fillStyle = theme.glow;
  const muzzle = [{mx:s*0.96,my:-s*0.05},{mx:s*0.96,my:s*0.05},{mx:s*0.78,my:-s*0.22},{mx:s*0.78,my:s*0.22}];
  for(const m of muzzle){ ctx.beginPath(); ctx.ellipse(m.mx, m.my, s*0.05, s*0.05, 0, 0, Math.PI*2); ctx.fill(); }
  ctx.restore();

  ctx.save(); ctx.translate(x, y);
  ctx.strokeStyle = (theme.glow || '#22d3ee') + '33'; ctx.lineWidth = Math.max(2, s*0.02);
  ctx.beginPath(); ctx.ellipse(0, 0, s*1.05, s*0.70, 0, 0, Math.PI*2); ctx.stroke();
  ctx.restore();
}

/* -------- Boss -------- */
const ENEMY_MIN_SIZE = 28, ENEMY_MAX_SIZE = 56;
const BOSS_SIZE_MULT = 1.1;
class Boss{
  constructor(){
    bossActive=true;
    const avgEnemy = (ENEMY_MIN_SIZE + ENEMY_MAX_SIZE) / 2;
    const baseBoss = Math.round(avgEnemy * BOSS_SIZE_MULT);
    const variants = [
      {name:'Sky Ace',     size: baseBoss,       hp:45, speed:0.72, shots:5, spread:Math.PI/7,  theme:BOSS_PALETTES.azure},
      {name:'Warhawk',     size: baseBoss + 6,   hp:70, speed:0.58, shots:7, spread:Math.PI/5,  theme:BOSS_PALETTES.scarlet},
      {name:'Night Raven', size: baseBoss + 12,  hp:90, speed:0.52, shots:8, spread:Math.PI/4,  theme:BOSS_PALETTES.midnight}
    ];
    this.v = variants[irand(0,variants.length-1)];
    this.size=this.v.size;
    this.maxHealth = this.v.hp + Math.floor(selectedStage*3);
    this.health=this.maxHealth;
    const edge = irand(0,3);
    if(edge===0){ this.x=-this.size; this.y=rand(80,WORLD_H-80);}
    else if(edge===1){ this.x=WORLD_W+this.size; this.y=rand(80,WORLD_H-80);}
    else if(edge===2){ this.x=rand(80,WORLD_W-80); this.y=-this.size;}
    else { this.x=rand(80,WORLD_W-80); this.y=WORLD_H+this.size; }
    this.speed=this.v.speed*DIFF.speed;
    this.turretAngle=0; this.sinceShot=0; this.shootDelay=650;
    this.ringTimer=0;
    currentBoss = this;
  }
  update(dt){
    const dx=player.x-this.x, dy=player.y-this.y, d=Math.hypot(dx,dy)||1;
    this.x+=(dx/d)*this.speed; this.y+=(dy/d)*this.speed;
    this.turretAngle=Math.atan2(player.y-this.y, player.x-this.x);
    this.sinceShot+=dt; this.ringTimer+=dt;
    if(graceMs===0 && this.sinceShot>=this.shootDelay && player.alive){
      this.sinceShot=0;
      for(let i=0;i<this.v.shots;i++){
        const a = this.turretAngle - this.v.spread/2 + (this.v.spread/(this.v.shots-1))*i;
        const tx = this.x + Math.cos(a)*100, ty = this.y + Math.sin(a)*100;
        const b = new EnemyBullet(this.x, this.y, tx, ty, a);
        b.size = 8;
        b.speed += this.v.name.includes('Sky Ace') ? 1.6 : 1.0;
        enemyBullets.push(b);
      }
    }
  }
  draw(){
    const s = this.size;
    const hullAngle = this.turretAngle + Math.PI/2;
    drawAirBoss(this.x, this.y, s, hullAngle, this.turretAngle, this.v.theme, nowTime);
    ctx.save();
    ctx.fillStyle='#0b1a27';
    ctx.font=`900 ${Math.max(24,s*0.20)}px system-ui, Arial`;
    ctx.textAlign='center'; ctx.textBaseline='middle';
    ctx.fillText(this.health, this.x, this.y);
    ctx.fillStyle='rgba(15,23,42,0.9)';
    ctx.font='900 16px system-ui, Arial';
    ctx.fillText(this.v.name, this.x, this.y - s*0.70);
    ctx.restore();
  }
}

/* =================== Background =================== */
function drawBackground(){
  if(bgReady){
    const iw = bgImg.naturalWidth || bgImg.width;
    const ih = bgImg.naturalHeight || bgImg.height;
    const scale = Math.max(WORLD_W/iw, WORLD_H/ih);
    const w = iw * scale, h = ih * scale;
    const x = (WORLD_W - w) / 2, y = (WORLD_H - h) / 2;
    ctx.drawImage(bgImg, x, y, w, h);
  } else {
    ctx.fillStyle = '#cde7ff'; ctx.fillRect(0,0,WORLD_W,WORLD_H);
  }
  const vg = ctx.createRadialGradient(WORLD_W/2, WORLD_H/2, Math.min(WORLD_W,WORLD_H)*0.55, WORLD_W/2, WORLD_H/2, Math.max(WORLD_W,WORLD_H)*0.9);
  vg.addColorStop(0,'rgba(255,255,255,0)'); vg.addColorStop(1,'rgba(0,0,0,0.12)');
  ctx.fillStyle = vg; ctx.fillRect(0,0,WORLD_W,WORLD_H);
}

/* -------- Boss HUD bar -------- */
function drawBossHealth(){
  if(!currentBoss) return;
  const pad = 12, w = Math.min(WORLD_W - pad*2, 520), h = 14;
  const x = (WORLD_W - w)/2, y = 12 + 36;
  const pct = Math.max(0, Math.min(1, currentBoss.health / currentBoss.maxHealth));
  ctx.save();
  ctx.fillStyle='rgba(0,0,0,0.12)'; ctx.fillRect(x-2, y-2, w+4, h+4);
  ctx.fillStyle='rgba(255,255,255,0.6)'; ctx.fillRect(x, y, w, h);
  const grd = ctx.createLinearGradient(x, y, x+w, y);
  grd.addColorStop(0,'#ef4444'); grd.addColorStop(1,'#dc2626');
  ctx.fillStyle = grd; ctx.fillRect(x, y, w*pct, h);
  ctx.font='900 14px system-ui, Arial'; ctx.fillStyle='#0b1a27'; ctx.textAlign='center';
  ctx.fillText('BOSS', x + w/2, y - 4);
  ctx.restore();
}

/* =================== Level progression (1–100, 15 kills per stage) =================== */
const LEVELS_TOTAL = 500;
const KILLS_PER_LEVEL = 15;
const PER_PAGE = 9;
const PAGES = Math.ceil(LEVELS_TOTAL / PER_PAGE);

let selectedStage = Number(localStorage.getItem('cfc_selected_level') || 1);
let unlockedLevel = Number(localStorage.getItem('cfc_unlocked_level') || 1);
unlockedLevel = Math.max(1, Math.min(LEVELS_TOTAL, unlockedLevel));
selectedStage = Math.max(1, Math.min(unlockedLevel, selectedStage));
let currentGoal = KILLS_PER_LEVEL;
let currentPage = Math.ceil(selectedStage / PER_PAGE) || 1;

/* Build/Render paginated grid */
function renderLevelPage(){
  if(!levelGrid) return;
  levelGrid.innerHTML = '';
  const start = (currentPage-1)*PER_PAGE + 1;
  const end = Math.min(start + PER_PAGE - 1, LEVELS_TOTAL);
  for(let n=start; n<=end; n++){
    const btn = document.createElement('button');
    btn.className = 'level-btn ' + (n>unlockedLevel ? 'locked' : 'unlocked');
    btn.type='button'; btn.dataset.level = String(n);
    btn.setAttribute('role','gridcell');
    btn.disabled = n>unlockedLevel;
    btn.innerHTML = `<span class="level-num">${n}</span>${n>unlockedLevel?'<span class="lock" aria-hidden="true">🔒</span>':''}`;
    if(n===selectedStage){ btn.classList.add('selected'); btn.setAttribute('aria-selected','true'); }
    btn.addEventListener('click', ()=>{
      if(n>unlockedLevel) return;
      selectedStage = n;
      localStorage.setItem('cfc_selected_level', String(selectedStage));
      currentGoal = KILLS_PER_LEVEL;
      updateLevelHeader();
      [...levelGrid.children].forEach(c => c.classList.toggle('selected', Number(c.dataset.level)===selectedStage));
      levelPlayBtn.disabled = false;
    });
    levelGrid.appendChild(btn);
  }
  if(lsPageLabel) lsPageLabel.textContent = `${currentPage} / ${PAGES}`;
  updateLevelHeader();
}
function updateLevelHeader(){
  lsSelected && (lsSelected.textContent = String(selectedStage));
  lsGoal && (lsGoal.textContent = String(currentGoal));
  unlockedLevelEl && (unlockedLevelEl.textContent = String(unlockedLevel));
  levelPlayBtn && (levelPlayBtn.disabled = selectedStage>unlockedLevel);
}
lsPrev?.addEventListener('click', ()=>{ currentPage = currentPage>1 ? currentPage-1 : PAGES; renderLevelPage(); });
lsNext?.addEventListener('click', ()=>{ currentPage = currentPage<PAGES ? currentPage+1 : 1; renderLevelPage(); });
levelBackBtn?.addEventListener('click', ()=>{ /* stay in start panel; optional UX hook */ });
levelPlayBtn?.addEventListener('click', ()=> startGame());

document.addEventListener('DOMContentLoaded', ()=>{ renderLevelPage(); });

/* =================== Update & Draw =================== */
function update(dt){
  if(!player.alive || paused || !gameStarted) return;

  nowTime += dt;
  graceMs = Math.max(0, graceMs - dt);

  handlePlayerMovement();

  spawnTimer += dt;
  if(spawnTimer > spawnInterval() && !bossActive){ enemies.push(new Enemy()); spawnTimer = 0; }
  for(let i=enemies.length-1;i>=0;i--) enemies[i].update(dt);

  // player bullets vs enemies
  for(let i=bullets.length-1;i>=0;i--){
    const b=bullets[i];
    if(!b.update()){ bullets.splice(i,1); continue; }
    for(let j=enemies.length-1;j>=0;j--){
      const e=enemies[j], dx=e.x-b.x, dy=e.y-b.y;
      if(Math.hypot(dx, dy) < (e.size*0.8) + b.size){
        e.health -= b.damage; if(e.hitTimer!==undefined) e.hitTimer=200;
        createFloatingText(e.x+rand(-12,12), e.y+rand(-12,12), '-'+b.damage, '#0b1a27', Math.max(16,(e.size||60)*0.34), 'rgba(255,255,255,.8)');
        bullets.splice(i,1);
        particles.push({ x:b.x, y:b.y, vx:rand(-1.5,1.5), vy:rand(-1.5,1.5), size:rand(2,5), life:rand(8,16), hue:rand(30,60), type:'spark' });

        const isBoss = e instanceof Boss;
        if(e.health<=0){
          score += isBoss ? 40 : Math.ceil(e.maxHealth*2);
          const coinGain = isBoss ? irand(8,14) : (irand(1,3) + Math.max(0, selectedStage-1));
          coins += coinGain; 
          saveCoins();
updateCoinsUI();
          if(!isBoss){
            kills += 1;
            killsEl && (killsEl.textContent=kills);
            applyPlayerShotTier();

            // === Stage goal check (15 kills) ===
            if (kills >= currentGoal && gameStarted && player.alive){
              advanceToNextLevel();
              return; // prevent double-processing this frame
            }
          }
          createFloatingText(e.x,e.y, isBoss? `+${coinGain}c BOSS` : `+${coinGain}c`, '#b45309', Math.max(20,(e.size||60)*0.40));
          synth.coin();

          if(isBoss){
            for(let k=0;k<3;k++) pickups.push(new Pickup(e.x+rand(-40,40), e.y+rand(-40,40),'health'));
            createFloatingText(WORLD_W/2, WORLD_H*0.25, 'BOSS DOWN', '#0b1a27', 50, 'rgba(255,255,255,.85)', 'red');
            bossActive=false; currentBoss=null;
          }else if(Math.random()<0.28){ pickups.push(new Pickup(e.x,e.y,'health')); }

          spawnExplosion(e.x,e.y, isBoss ? 2.2 : (1 + (e.maxHealth*0.12)));
          enemies.splice(j,1); synth.death();

          // (Removed old "every 10 kills = +1 level" to avoid conflict with stage system)

          if(!bossActive && kills >= nextBossAt){
            enemies.push(new Boss());
            createFloatingText(WORLD_W/2, WORLD_H*0.25, 'BOSS INCOMING', '#0b1a27', 50, 'rgba(255,255,255,.85)', 'red');
            nextBossAt += BOSS_INTERVAL;
          }
        }
        break;
      }
    }
  }

  // enemy bullets vs player
  for(let i=enemyBullets.length-1;i>=0;i--){
    const eb=enemyBullets[i]; if(!eb.update()){ enemyBullets.splice(i,1); continue; }
    const dx=player.x-eb.x, dy=player.y-eb.y;
    if(Math.hypot(dx,dy) < player.size*0.45 + eb.size){ enemyBullets.splice(i,1); damagePlayer(1); }
  }

  // bullet vs bullet
  for(let i=bullets.length-1;i>=0;i--){
    const b=bullets[i];
    for(let j=enemyBullets.length-1;j>=0;j--){
      const eb=enemyBullets[j], dx=b.x-eb.x, dy=b.y-eb.y;
      if(dx*dx+dy*dy < (b.size+eb.size)*(b.size+eb.size)){
        const mx = (b.x+eb.x)/2, my=(b.y+eb.y)/2;
        spawnExplosion(mx,my,0.8);
        enemyBullets.splice(j,1); bullets.splice(i,1);
        screenShake = Math.max(screenShake, 8); break;
      }
    }
  }

  // enemies touching player
  for(const e of enemies){
    const dx=player.x-e.x, dy=player.y-e.y;
    if(Math.hypot(dx,dy) < (e.size*0.7 + player.size*0.45)) damagePlayer(1);
  }

  // pickups
  for(let i=pickups.length-1;i>=0;i--){
    const p=pickups[i]; if(!p.update(dt)){ pickups.splice(i,1); continue; }
    const dx=player.x-p.x, dy=player.y-p.y;
    if(Math.hypot(dx,dy) < player.size*0.4 + p.r){
      if(p.type==='health'){
        const gain=irand(2,4);
        player.hp=Math.min(player.maxHP,player.hp+gain);
        hpEl && (hpEl.textContent=player.hp);
        createFloatingText(player.x,player.y-50,`+${gain} HP`,'#10b981',22);
        synth.heal();
      }
      pickups.splice(i,1);
    }
  }

  scoreEl && (scoreEl.textContent=score);
  enemiesEl && (enemiesEl.textContent=enemies.length);
}

/* Damage & Game Over */
function damagePlayer(dmg){
  if(!player.alive) return;
  const final = Math.max(1, Math.round(dmg * DIFF.damage));
  player.hp = Math.max(0, player.hp - final); hpEl && (hpEl.textContent = player.hp);
  createFloatingText(player.x, player.y - 32, `-${final}`, '#0b1a27', 24, 'rgba(255,255,255,.85)', 'red');
  synth.hit(); screenShake = Math.max(screenShake, 6);
  if(player.hp<=0){ player.alive=false; showGameOver(); synth.gameover(); }
}
function showGameOver(){
  paused = true; gameStarted = false; synth.setPaused(true);
  hideAllPanels(); overlayTitle.textContent='Game Over'; document.getElementById('gameOverInfo').textContent=`Kills:${kills} | Stage:${selectedStage} | Coins:${coins}`;
  gameOverPanel.style.display='block'; overlay.classList.remove('hidden');
}

/* --------- Drawing --------- */
function draw(){
  ctx.save();
  if(screenShake>0){ ctx.translate(rand(-screenShake,screenShake), rand(-screenShake,screenShake)); screenShake *= 0.88; if(screenShake<0.5) screenShake=0; }
  drawBackground();
  if (currentBoss) drawBossHealth();
  if(player.alive) drawPlayer();
  enemies.forEach(e=>e.draw()); bullets.forEach(b=>b.draw()); enemyBullets.forEach(eb=>eb.draw()); pickups.forEach(p=>p.draw()); drawParticles();
  ctx.restore();
}
function loop(t){
  const dt=t-last; last=t;
  update(dt);
  draw();
  requestAnimationFrame(loop);
}
requestAnimationFrame(loop);

/* =================== Start/Pause/Restart =================== */
function hideAllPanels(){ startPanel.style.display='none'; pausePanel.style.display='none'; gameOverPanel.style.display='none'; }
function showStart(){ hideAllPanels(); overlayTitle.textContent='Car Fire Combat'; startPanel.style.display='block'; overlay.classList.remove('hidden'); }
function showPause(){ hideAllPanels(); overlayTitle.textContent='Paused'; pausePanel.style.display='block'; overlay.classList.remove('hidden'); }

function startGame(){
  // --- Respect locked progression & selection ---
  selectedStage = Math.max(1, Math.min(unlockedLevel, Number(selectedStage || 1)));
  localStorage.setItem('cfc_selected_level', String(selectedStage));

  // Use per-stage goal (fallback to constant if killsGoalFor isn't present)
  currentGoal = (typeof killsGoalFor === 'function')
    ? killsGoalFor(selectedStage)
    : (typeof KILLS_PER_LEVEL !== 'undefined' ? KILLS_PER_LEVEL : 15);

  // --- Apply difficulty ---
  DIFF = {...DIFF_TABLE[selectedMode]};
  if (modeLabel) modeLabel.textContent = selectedMode;

  // --- Reset runtime state ---
  enemies = []; bullets = []; enemyBullets = []; particles = []; pickups = []; shockwaves = [];
  score = 0; kills = 0; paused = false; gameStarted = true; screenShake = 0;
  bossActive = false; currentBoss = null; nextBossAt = FIRST_BOSS_KILLS;

  // Timers / clocks
  spawnTimer = 0;
  nowTime = 0;
  graceMs = 3000;
  levelStartTime = performance.now(); // for Level Complete timing

  // --- Player ---
  player.x = WORLD_W/2; player.y = WORLD_H/2;
  player.vx = 0; player.vy = 0; player.wheelSpin = 0;
  player.maxHP = DIFF.playerHP; player.hp = player.maxHP; player.alive = true;

  // --- UI sync ---
  joyMag = 0; joyVec.x = 0; joyVec.y = 0; hideJoy();
  if (scoreEl)   scoreEl.textContent   = score;
  if (enemiesEl) enemiesEl.textContent = 0;
  if (killsEl)   killsEl.textContent   = kills;
  if (hpEl)      hpEl.textContent      = player.hp;
  if (levelEl)   levelEl.textContent   = String(selectedStage);

  overlay.classList.add('hidden');
  synth.setPaused(false);
  playerShots = 1;

  // Nice toast with the stage goal
  createFloatingText(
    WORLD_W/2, WORLD_H*0.22,
    `Stage ${selectedStage} • Goal: ${currentGoal} Kills`,
    '#0b1a27', 28, 'rgba(255,255,255,.85)'
  );

  // Initial spawn
  setTimeout(()=>{ enemies.push(new Enemy()); }, 500);
}

function togglePause(state){ if(!gameStarted) return; paused = state; synth.setPaused(state); if(paused) showPause(); else overlay.classList.add('hidden'); }
function restart(){
  enemies=[]; bullets=[]; enemyBullets=[]; particles=[]; pickups=[]; shockwaves=[];
  score=0; kills=0; coins=0; paused=false; player.hp=player.maxHP; player.alive=true; screenShake=0;
  bossActive=false; currentBoss=null; nextBossAt=FIRST_BOSS_KILLS;
  player.x=WORLD_W/2; player.y=WORLD_H/2; player.vx=0; player.vy=0; player.wheelSpin=0;
  joyMag=0; joyVec.x=0; joyVec.y=0; hideJoy();
  graceMs = 3000;
  scoreEl && (scoreEl.textContent=score);
  enemiesEl && (enemiesEl.textContent=0);
  killsEl && (killsEl.textContent=kills);
  levelEl && (levelEl.textContent=String(selectedStage));
  coinsEl && (coinsEl.textContent=coins);
  hpEl && (hpEl.textContent=player.hp);
  overlay.classList.add('hidden'); gameStarted=true; synth.setPaused(false);
  setTimeout(()=>{ enemies.push(new Enemy()); }, 500);
  playerShots = 1;
}

/* Optional: mouse aim helper on desktop */
function updateAim(e){
  const r=canvas.getBoundingClientRect(); const mx=e.clientX-r.left, my=e.clientY-r.top;
  player.angle=Math.atan2(my-player.y,mx-player.x)+Math.PI/2;
}
canvas.addEventListener('mousemove', updateAim);

/* =================== Flags UI =================== */
document.addEventListener("DOMContentLoaded", () => {
  const LS_FLAGS = { player: "cfc_player_flag", enemy: "cfc_enemy_flag", spawn: "cfc_enemy_spawn" };
  const ISO_COUNTRIES = {
    AF:"Afghanistan", PK:"Pakistan", AL:"Albania", DZ:"Algeria", US:"United States", IN:"India", GB:"United Kingdom",
    DE:"Germany", FR:"France", BR:"Brazil", JP:"Japan", CN:"China", RU:"Russia",
    CA:"Canada", IT:"Italy", ES:"Spain", MX:"Mexico", KR:"South Korea", AU:"Australia",
  };
  function ccToFlagEmoji(cc){
    if (!cc || cc.length !== 2) return "🏳️";
    const a = cc[0].toUpperCase().charCodeAt(0) - 65 + 0x1F1E6;
    const b = cc[1].toUpperCase().charCodeAt(0) - 65 + 0x1F1E6;
    return String.fromCodePoint(a, b);
  }
  const playerFlagSel = document.getElementById("playerFlagSel");
  const enemyFlagSel  = document.getElementById("enemyFlagSel");
  const enemySpawnSel = document.getElementById("enemySpawnSel");
  function fillFlagSelect(sel, stored){
    if (!sel) return;
    sel.innerHTML = "";
    Object.entries(ISO_COUNTRIES).forEach(([code, name]) => {
      const o = document.createElement("option");
      o.value = code;
      o.textContent = `${ccToFlagEmoji(code)}  ${name}`;
      if (code === stored) o.selected = true;
      sel.appendChild(o);
    });
  }
  const storedPlayer = localStorage.getItem(LS_FLAGS.player) || "US";
  const storedEnemy  = localStorage.getItem(LS_FLAGS.enemy) || "IN";
  const storedSpawn  = localStorage.getItem(LS_FLAGS.spawn) || "random";
  fillFlagSelect(playerFlagSel, storedPlayer);
  fillFlagSelect(enemyFlagSel, storedEnemy);
  if (enemySpawnSel) enemySpawnSel.value = storedSpawn;
  playerFlagSel?.addEventListener("change", () => { localStorage.setItem(LS_FLAGS.player, playerFlagSel.value); });
  enemyFlagSel?.addEventListener("change", () => { localStorage.setItem(LS_FLAGS.enemy, enemyFlagSel.value); });
  enemySpawnSel?.addEventListener("change", () => { localStorage.setItem(LS_FLAGS.spawn, enemySpawnSel.value); });
});
const flagToggle = document.getElementById("flagModeToggle");
const LS_FLAG_MODE = "cfc_flag_mode";
const savedMode = localStorage.getItem(LS_FLAG_MODE);
if(savedMode !== null){ flagToggle.checked = savedMode === "on"; }
flagToggle.addEventListener("change", ()=>{ localStorage.setItem(LS_FLAG_MODE, flagToggle.checked ? "on" : "off"); });
/* ===== Celebration / Level Complete ===== */
let levelStartTime = 0;

function fmtTime(ms){
  const t = Math.max(0, Math.floor(ms/1000));
  const m = Math.floor(t/60).toString().padStart(2,'0');
  const s = (t%60).toString().padStart(2,'0');
  return `${m}:${s}`;
}

function celebrateBursts(n=3){
  // spawn a few big bursts using your existing particle system
  const cx = WORLD_W/2, cy = WORLD_H/2;
  for(let i=0;i<n;i++){
    setTimeout(()=>{
      // a richer burst than spawnExplosion: more colorful sparks
      for(let k=0;k<36;k++){
        particles.push({
          x: cx + rand(-40,40),
          y: cy + rand(-40,40),
          vx: rand(-4.0,4.0),
          vy: rand(-4.0,4.0),
          size: rand(2,6),
          life: rand(26,46),
          hue: rand(10,55),
          type: (Math.random()<0.6 ? 'spark' : 'fire')
        });
      }
      shockwaves.push({x:cx, y:cy, r:6, vr:8, alpha:0.9});
      screenShake = Math.max(screenShake, 10);
      synth.coin();
    }, i*260);
  }
}

function showLevelComplete(){
  paused = true;
  gameStarted = false;
  synth.setPaused(true);

  // Update stats
  document.getElementById('lcLevel').textContent = String(selectedStage);
  document.getElementById('lcGoal').textContent  = String(currentGoal);
  const elapsed = performance.now() - levelStartTime;
  document.getElementById('lcTime').textContent  = fmtTime(elapsed);

  // Reset gift state for this panel
  giftOpened = false;
  const card = document.getElementById('giftCard');
  const wrap = document.getElementById('giftAmountWrap');
  if (card) card.classList.remove('open');
  if (wrap) wrap.classList.add('hidden');

  // Show panel
  hideAllPanels();
  document.getElementById('levelCompletePanel').style.display = 'block';
  overlayTitle.textContent = 'Level Complete!';
  overlay.classList.remove('hidden');

  // Fun flare
  celebrateBursts(4);
}

/* Stage advancement (called when kills reach goal) */
function advanceToNextLevel(){
  // Unlock next stage (persist)
  if (unlockedLevel < LEVELS_TOTAL && unlockedLevel === selectedStage){
    unlockedLevel = Math.min(LEVELS_TOTAL, unlockedLevel + 1);
    localStorage.setItem('cfc_unlocked_level', String(unlockedLevel));
  }

  // Refresh header/grid numbers
  unlockedLevelEl && (unlockedLevelEl.textContent = String(unlockedLevel));
  renderLevelPage();

  // Show the "Level Complete" overlay (Next / Retry / Menu)
  showLevelComplete();
}


</script>

</body>
</html>

